#+TITLE: Andrew's Learn Ruby Notes
#+AUTHOR: Andrew Buckingham
#+STARTUP: indent
#+OPTIONS: num:nil
#+OPTIONS: html-postamble:nil
#+TODO: TODO(t) | Started(s) | Waiting(w) | Canceled(c) | DONE(d)(@) | Questions(q) | Note(n)

* Preparation

** Exercise 1
Create a directory named my_folder and then navigate inside that directory. Create two files named one.rb and two.rb in the my_folder directory. Write a ruby program that outputs the line this is file one when you run the one.rb file. Then write another program that outputs this is file two when you run the two.rb file. (Hint: one.rb should have this in it puts "this is file one")
*** Solution

   #+BEGIN_SRC ruby
     # one.rb
     puts "this is file one"
        #+END_SRC

   #+BEGIN_SRC ruby
     # two.rb
   puts "this is file two"
   #+END_SRC


** Exercise 2
When you are finished with the above and both programs are working correctly, navigate to the directory above the my_folder directory and delete all of the content you generated with one command.
*** Solution
#+BEGIN_SRC sh
小A曰:ls
one.rb	two.rb
小A曰:cd ..
小A曰:ls
my_folder
小A曰:rm -R my_folder/
小A曰:ls
小A曰:
#+END_SRC

* The Basics
** Strings
   - Strings can use either double quotes ("") or single quotes (''), and you can escape quotes, when necessary ('This is Andrew\'s string.')
   - String interpolation (concatenation) *only works with double quotes*
     - Syntax: "Here's how to use string interpolation with a #{Ruby Expression}"
       *Example:*       

   #+BEGIN_SRC ruby 
a = 'ten'
"My favorite number is #{a}!"
   #+END_SRC
** Symbols
- You can use symbols to reference things, like strings, that you don't intend to print or edit.
- Often referred to as "immutable" (though this is apparently not 100% correct)

#+BEGIN_SRC ruby
# Examples of symbols
:name
:a_symbol
:"surprisingly, this is also a symbol" 
   #+END_SRC

** Numbers
Integers do not contain decimal points. Floats do.
  
*** Integers
    9, 1, 4, 1000

*** Floats
    9.1, 44.44409, 9.01234

** nil
The *nil* variable allows us to express an /empty value/ (it equals nothing). Ruby also outputs nil when an expected value is not returned.

In this example, puts prints out a statement, but returns nothing (nil):

   #+BEGIN_SRC ruby
# An example from irb

irb(main):006:0> puts "I love Ruby!"
puts "I love Ruby!"
I love Ruby!
=> nil
irb(main):007:0> 
   #+END_SRC

We can also check to see if a value is equal to nil:

#+BEGIN_SRC ruby
nil.nil?
=> true
irb(main):008:0> "nil".nil?
"nil".nil?
=> false
irb(main):009:0> 0.nil?
0.nil?
=> false
irb(main):010:0> "nothing".nil?
"nothing".nil?
=> false

# Note that following is also false:
irb(main):011:0> false == nil
false == nil
=> false

#+END_SRC

As expected, in the first example, *nil* is equal to 'nil', but strings or numbers (including the string, "nil" have a value, and so they cannot equal the empty value of nil.

When nil is used in a condtional expression, rather than as output, the result will be treated as false, because the value is not empty. Note these examples from the text:

#+BEGIN_SRC ruby
# The xpression is not empty, so it is false.
irb :001 > if nil
irb :002 > puts "Hello, World!"
irb :003 > end
=> nil

# The expression runs, and the output is nil.
irb :001 > if 1
irb :002 > puts "Hello, World!"
irb :003 > end
Hello, World!
=> nil
#+END_SRC

** Operations (Mathematical)
   These work as I would expect (similar to JavaScript).
*** Adding, Subtracting, and Multiplying Integers

*Addition (+)*
    #+BEGIN_SRC ruby
2 + 2
=> 4
    #+END_SRC

    #+RESULTS:
    : 4

*Subtraction (-)*
    #+BEGIN_SRC ruby
49 - 47
=> 2
    
    #+END_SRC

    #+RESULTS:
    : 2

*Multiplication (*)*
#+BEGIN_SRC ruby
144 * 144
=> 20736    
    #+END_SRC

    #+RESULTS:
    : 20736

** Division vs. Modulus

*** Division (/)
    #+BEGIN_SRC ruby
144 / 2
=> 2
    #+END_SRC

    #+RESULTS:
    : 72

*** Modulo
    #+BEGIN_SRC ruby
16 / 4
=> 0

16 / 3
=> 5
    
    #+END_SRC

    #+RESULTS:
    : 5

*** Multiplying Floats and Decimals
    #+BEGIN_SRC ruby
15.0 / 4
=> 3.75

48.0 * 7.2
=> 345.6

    
    #+END_SRC

    #+RESULTS:
    : 3.75

*** Equality Comparison

    #+BEGIN_SRC ruby
4 == 4
=> true

4 == '4'
=> false
      
'book' == "book"
=> true

'four' == 4
=> false

'four' == '4'
=> false

    #+END_SRC

    #+RESULTS:
    : false

*** String Concatenation
    #+BEGIN_SRC ruby
"I love" + " Ruby!"
    
    #+END_SRC

    #+RESULTS:
    : I love Ruby!

#+BEGIN_SRC ruby
"1" + "1" 
#+END_SRC

#+RESULTS:
: 11

    *We cannot concatenate a string and a number*

#+BEGIN_SRC ruby
1 + "Love"
#+END_SRC    

#+RESULTS:
-:3:in `+': String can't be coerced into Fixnum (TypeError)
	from -:3:in `main'
	from -:5:in `<main>'

** Basic Data Structures
   
*** Arrays

    #+BEGIN_SRC ruby
[1,2,3,4]
    
    #+END_SRC

    #+RESULTS:
    | 1 | 2 | 3 | 4 |

    Predictably, the index starts with 0:

    #+BEGIN_SRC ruby
irb(main):012:0> [1, 2, 3, 4] [0]
[1, 2, 3, 4] [0]
=> 1
irb(main):013:0* [1, 2, 3, 4] [1]
[1, 2, 3, 4] [1]
=> 2
irb(main):014:0> [1, 2, 3, 4] [2]
[1, 2, 3, 4] [2]
=> 3
irb(main):015:0> [1, 2, 3, 4] [3]
[1, 2, 3, 4] [3]
=> 4
irb(main):016:0> [1, 2, 3, 4] [4]
[1, 2, 3, 4][4]
=> nil 
    #+END_SRC
In the example above, there is no 4th index, so the result is nil.
    
*** Hashes {}
    - Function as dictionary/key-value pairs
    - consists of a *key* and a *value*.
      + The key is usually represented by a *:symbol*.
      + The value follows the *=>*.

        
#+BEGIN_SRC ruby
irb(main):019:0> {:dog => 'barks'}
{:dog => 'barks'}
=> {:dog=>"barks"}
irb(main):020:0> {:dog => 'barks', :cat => 'meows', :pig => 'oinks'}
{:dog => 'barks', :cat => 'meows', :pig => 'oinks'}
=> {:dog=>"barks", :cat=>"meows", :pig=>"oinks"}
#+END_SRC

We can retrieve any value by its key:    
#+BEGIN_SRC ruby
# Can you spot the error?
irb(main):021:0> 
{dog => 'barks', :cat => 'meows', :pig => 'oinks'}[:cat]
NameError: undefined local variable or method `dog' for main:Object
	from (irb):21
	from /usr/bin/irb:12:in `<main>'
#+END_SRC

In the example above, I forgot to add the ':' before 'dog'. Remember that strings require single or double quotes, and symbols require colons. Without either of these, your statements will throw an error.

I've fixed the error. Now we can search for the sound a cat makes:

#+BEGIN_SRC ruby
irb(main):022:0> {:dog => 'barks', :cat => 'meows', :pig => 'oinks'}[:cat]
{:dog => 'barks', :cat => 'meows', :pig => 'oinks'}[:cat]
=> "meows"{:cat => 'meows'}
#+END_SRC      

Many coding errors are just tiny punctuation or spacing errors. Syntax highlighting can help point those out, but experience reading error messages and a sharp eye are essential traits. For example, I remember once, when I was trying to debug a CSS file, it took me forever to figure out why it wasn't working. It turns out I'd used a colon instead of a semi-colon. Lesson learned...

** Expressions and Return
   - When you use the IRB, you'll see the 'hash rocket': *=>*
   - Everything in Ruby is an expression, and it always returns something, even if only /nil/

*** Puts vs. Return
    - puts: Ruby puts something on the screen, but it doesn't return what is printed to the screen. For example, *do* does something, but it also returns a value. Puts does not return the value.

      In these examples, *put* /prints/ a value to the screen, but it /returns/ nil:

      #+BEGIN_SRC ruby
irb(main):023:0> puts 'stuff'
puts 'stuff'
stuff
=> nil
irb(main):024:0> a = puts 'stuff'
a = puts 'stuff'
stuff
=> nil
irb(main):025:0> puts a
puts a
=> nil
#+END_SRC
      
*** Exercises

**** Problem 1
Add two strings together that, when concatenated, return your first and last name as your full name in one string.

For example, if your name is John Doe, think about how you can put "John" and "Doe" together to get "John Doe".

**** Solution 1
Here are three ways. The first is the one I came up with. It can be run in irb:     
#+BEGIN_SRC ruby
irb(main):026:0> "Andrew " + "Buckingham"
"Andrew " + "Buckingham"
=> "Andrew Buckingham"
#+END_SRC
(Note the space after "Andrew ").

The solution came up with two other ways, by assigning variables in the first case, and using string interpolation in the second:

#+BEGIN_SRC ruby :tangle 02_basics/solution1.rb
# #1: My original, (overly?) simple solution
puts "Andrew " + "Buckingham" # Andrew Buckingham

# #2: From the books's solution; assigns variables and then concatenates them:

fname = "Andrew"
lname = "Buckingham"

puts fname + " " + lname

# #3: From the book's solution; using string interpolation:
puts "#{fname} #{lname}"

#+END_SRC

File: [[file:02_basics/solution1.rb][02_basics/solution01.rb]]
#+BEGIN_SRC sh
# See 02_basics/solution01.rb for Ruby file.
小A曰: ruby solution1.rb 
Andrew Buckingham
Andrew Buckingham
Andrew Buckingham

#+END_SRC



**** Problem 2
2. Use the modulo operator, division, or a combination of both to take a 4 digit number and find 1) the thousands number 2) the hundreds 3) the tens and 4) and the ones.
     
**** Solution 2

#+BEGIN_SRC ruby :tangle 02_basics/solution2.rb
puts 6732 / 1000
puts 6732 % 1000 / 100
puts 6732 % 1000 % 100 / 10
puts 6732 % 1000 %100 % 10     
#+END_SRC

Output: [[file:02_basics/solution2.rb][02_basics/solution2.rb]]
#+BEGIN_SRC sh
小A曰:ruby solution2.rb 
6
7
3
2
#+END_SRC

I'll be honest. I didn't quite understand what I was supposed to do, until I saw the solution. I understood the modulo, because it's the same in JavaScript, and once I saw it, the directions made sense. But this was a fun exercise; it's a very simple preview of the kinds of problem-solving tasks that I'll become better at with practice!

**** Problem 3
Write a program that uses a hash to store a list of movie titles with the year they came out. Then use the *puts* command to make your program print out the year of each movie to the screen. The output for your program should look something like this:

#+BEGIN_SRC ruby
1975
2004
2013
2001
1981
#+END_SRC
**** Solution 3
#+BEGIN_SRC ruby :tangle 02_basics/solution3.rb
       movies = {:The_Empire_Strikes_Back =>'1980',
         :The_Dark_Knight => '2008',
         :Avatar => '2009',
         :The_Blind_Side => '2009',
         :Into_the_Fire => '2010'}  

       puts movies[:The_Empire_Strikes_Back]
       puts movies[:The_Dark_Knight]
       puts movies[:Avatar]
       puts movies[:The_Blind_Side]
       puts movies[:Into_the_Fire]
     #+END_SRC

File: [[file:02_basics/solution3.rb][02_basics/solution3.rb]]
#+BEGIN_SRC sh
小A曰:ruby solution3.rb
1980
2008
2009
2009
2010
#+END_SRC

**** Problem 4
Use the dates from the previous example and store them in an array. Then make your program output the same thing as exercise 3.

File: [[file:02_basics/solution4.rb][02_basics/solution4.rb]]

**** Solution 4
#+BEGIN_SRC ruby :tangle 02_basics/solution4.rb
# My solution
years = [1980, 2008, 2009, 2009, 2010]
puts years

# Book solution
dates = [1980, 2008, 2009, 2009, 2010]

puts dates[0]
puts dates[1]
puts dates[2]
puts dates[3]
puts dates[4]
#+END_SRC

***** TODO Find out if there is a difference between our solutions in practical coding situations
*Note:* My solution looks the same as the book's but I can understand the difference in our approach. My reasoning was that if I created a variable (years), I could call that variable, and it would list the dates. The book calls each index, one at a time. Although the output was the same for me, I wonder if there might be a situation where mine would not work well.

**** Problem 5
Write a program that outputs the factorial of the numbers 5, 6, 7, and 8.
**** Solution 5
I need to create a program that outputs something like this:

#+BEGIN_SRC ruby
puts 5 * 4 * 3 * 2 * 1 
puts 6 * 5 * 4 * 3 * 2 * 1
puts 7 * 6 * 5 * 4 * 3 * 2 * 1
puts 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1
#+END_SRC

It seems like that works in irb. But perhaps I could make it a bit more elegant with variables.

#+BEGIN_SRC ruby :tangle 02_basics/solution5.rb
# Write a program that outputs the factorial of the numbers 5, 6, 7, and 8.
# My solution
five = 5 * 4 * 3 * 2 * 1
six = 6 * 5 * 4 * 3 * 2 * 1
seven = 7 * 6 * 5 * 4 * 3 * 2 * 1
eight = 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1

puts five
puts six
puts seven
puts eight

# Book solution
puts 5 * 4 * 3 * 2 * 1 
puts 6 * 5 * 4 * 3 * 2 * 1
puts 7 * 6 * 5 * 4 * 3 * 2 * 1
puts 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1

# This is the same as what I first came up with, but then I decided to assign variables...

#+END_SRC
***** Note 
It looks like my first instinct was correct; the book came up with the same answer. I suppose the one advantage of using variables would be that I could use them again, if needed.

**** Problem 6
Write a program that calculates the squares of 3 float numbers of your choosing and outputs the result to the screen.

*File:* [[file:02_basics/solution6.rb][02_basics/solution6.rb]]
**** Solution 6
#+BEGIN_SRC ruby :tangle 02_basics/solution6.rb
# Calculate the squares of 3 float numbers of your choosing and outputs the result to the screen.
puts 40.3 * 40.3
puts 59.5959 * 59.5959
puts 999.99191874 * 999.99191874
#+END_SRC

*Bonus*
This summer, I learned the 'get.chomps' method. I think I could use that to create an interactive program here, that asks the user to provide the floats...

*File:* [[file:02_basics/solution6_bonus.rb][02_basics/solution6_bonus.rb]]
#+BEGIN_SRC ruby :tangle 02_basics/solution6_bonus.rb
# Asks user to provide three floats and then outputs the result to the screen.

puts "Please provide three numbers, with decimal points and at least one digit."
first_number = gets.chomp.to_f
second_number = gets.chomp.to_f
third_number = gets.chomp.to_f

puts "I will now give you the squares and cubes of each of the numbers you have provided."


puts "The square of the first number is #{first_number * first_number}. The cube is  #{first_number * first_number * first_number}."
puts "The square of the second number is #{second_number * second_number}. The cube is #{second_number * second_number * second_number}."
puts "The square of the third number is #{third_number * third_number}. The cube is #{third_number * third_number * third_number}."

#+END_SRC
I had trouble getting that to work, because I was trying to concatenate everything, so it kept throwing errors. The lines looked like this:

#+BEGIN_SRC ruby
puts "The square of the first number is " first_number * first_number "." "The cube is " first_number * first_number * first_number "."
#+END_SRC

Based on my experience with JavaScript, that seemed to make sense to me, but I kept getting errors similar to this:

#+BEGIN_SRC sh
solution6_bonus.rb:9:in `+': no implicit conversion of Float into String (TypeError)
	from solution6_bonus.rb:9:in `<main>'
#+END_SRC

I checked the Ruby documentation, and had decided that the problem was that I wasn't using the correct syntax to put strings and variables on the same line. A simple searched revealed the answer: string interpolation! See this link: http://stackoverflow.com/questions/13526847/ruby-puts-string-and-integer-on-same-line

I just thought of one more way to improve the program. Instead of saying, "The square of the first number is..." I can use string interpolation to show the user the number he/she entered.

*File:* [[file:02_basics/solution6_bonus_improved.rb][02_basics/solution6_bonus_improved.rb]]
#+BEGIN_SRC ruby :tangle 02_basics/solution6_bonus_improved.rb
puts "Please provide three numbers, with decimal points and at least one digit."
first_number = gets.chomp.to_f
second_number = gets.chomp.to_f
third_number = gets.chomp.to_f

puts "I will now give you the squares and cubes of each of the numbers you have provided."


puts "The square of #{first_number} is #{first_number * first_number}. The cube is  #{first_number * first_number * first_number}."
puts "The square of #{second_number} is #{second_number * second_number}. The cube is #{second_number * second_number * second_number}."
puts "The square of #{third_number} is #{third_number * third_number}. The cube is #{third_number * third_number * third_number}."

#+END_SRC

And here's the solution from the book:

#+BEGIN_SRC ruby
puts 4.30 * 4.30
puts 6.13 * 6.13
puts 124.34 * 124.34
#+END_SRC

That was a bit of a detour, but I learned a valuable lesson. And it was really fun to solve that problem!
**** Problem 7
What does the following error message tell you?

#+BEGIN_SRC sh
SyntaxError: (irb):2: syntax error, unexpected ')', expecting '}' from /usr/local/rvm/rubies/ruby-2.0.0-rc2/bin/irb:16:in `<main>' 
#+END_SRC
**** Solution 7

*My solution:* "The coder typed a ')' instead of a '}' (probably when closing a hash)."

*The book's solution:* "There is an opening bracket somewhere in the program without a closing bracket following it. It may have happened when creating a hash."

* Variables
- Use this syntax when assigning variables: <variable_name> = <variable value>
- Be careful to assign a variable names that are unique, and yet easy for others (or you, at a later date) to understand.
- Variables contain information that we can use again, and are a useful way to abstract data. As the author reminds us, "It is helpful to think of variables as containers that hold information. Their sole purpose is to label and store data in memory. This data can then be used throughout your program."

** Assigning Value to Variables
   - Use descriptive/understandable variable names
   - Use '=' for assignment.
   - Use snake_case for variable names.
   - '=' is an assignment operator. '==' is an equality variable. Be careful not to confuse them. /(Unlike JS, Ruby does not appear to have a '===' operator.)/

#+BEGIN_SRC ruby
irb(main):032:0* first_name = "Andrew"
first_name = "Andrew"
=> "Andrew"

#+END_SRC

Now, when we call the variable:

#+BEGIN_SRC ruby
irb(main):033:0> first_name
first_name
=> "Andrew"

#+END_SRC

- "Variables point to values in memory."
- The value *Andrew* is a string. We can reference that in our program by calling the variable, *first_name*
   #+BEGIN_SRC ruby
a = 4
# 4

b = a
# 4

a = 7
# 7

b

# b still equals 4, even though variable a = 7.
   
   #+END_SRC

** Variable Scope
- Defined by where the variable was created/initialized
- Determined by blocks
  
*** *Inner scope can access variables initialized in an outer scope, but not vice versa.*

#+BEGIN_SRC ruby
# scope.rb

a = 5 # variable is initialized in the outer scope
3.times do |n| a = 3 # is a accessible here, in an inner scope?
end puts a 

# a = 3
#+END_SRC    

    Another example:

#+BEGIN_SRC ruby
# scope.rb
a = 5

3.times do |n|
  a = 3
  b = 5 # b is initialized in the inner scope
end

puts a
puts b

# is b accessible here, in the outer scope? 
    
#+END_SRC

It didn't work. I got the following error:

#+BEGIN_SRC sh
scope.rb:10:in `<main>': undefined local variable or method `b' for main:Object (NameError)
    
#+END_SRC

According to the book: This is because the variable b is not available outside of the do/end block in which it is initialized. When we call puts b it is not available within that outer scope.

/(This isn't a surprise. I've seen the same behavior in JS.)/

Another example, with a method:
#+BEGIN_SRC ruby
a = 5

def some_method
a = 3
end

puts a

# a = 5
#+END_SRC

From the text:

"What's the value of a? Still 5, because methods create their own scope that's entirely outside of the execution flow. We'll cover this in more detail when we talk about methods, but for now, make sure you don't mix up do/end with methods when you're working with variable scope issues.

*Note: the key distinguishing factor for deciding whether code delimited by {} or do/end is considered a block (and thereby creating a new scope for variables), is seeing if the {} or do/end immediately follows a method invocation.*

For example:

#+BEGIN_SRC ruby
arr = [1, 2, 3]

for i in arr do
  a = 5 # a is initialized here
end

puts a # is it accessible here? (A: Yes!)
    
#+END_SRC

In this case, *for...do/end* did not create a new inner scope, because these are part of standard Ruby language, and not method calls.

(!) New blocks are created when we use *each*, *times*, or other methods, followed by:
    - {}
    - do/end

    
** Exercises

*** Problem 1
Write a program called name.rb that asks the user to type in their name and then prints out a greeting message with their name included.

*File:* [[file:03_variables/name.rb][03_variables/name.rb]]
*** Solution 1

#+BEGIN_SRC ruby :tangle 03_variables/name.rb
# 03_variables/name.rb
# Asks user for his/her name, and prints it out with a greeting.

puts "What's your name?"
name = gets.chomp

puts 'Hello, ' + name + '!'

#+END_SRC

Here's the book's solution. Almost identical.

#+BEGIN_SRC ruby
# name.rb
puts "What is your name?"
name = gets.chomp
puts "Hello " + name
#+END_SRC


*** Problem 2
Write a program called age.rb that asks a user how old they are and then tells them how old they will be in 10, 20, 30 and 40 years. Below is the output for someone 20 years old.

#+BEGIN_SRC ruby
# output of age.rb for someone 20 yrs old
How old are you?
In 10 years you will be: 30
In 20 years you will be: 40
In 30 years you will be: 50
In 40 years you will be: 60

#+END_SRC

*** Solution 2

*File:* [[file:03_variables/age.rb][03_variables/age.rb]]
#+BEGIN_SRC ruby :tangle 03_variables/age.rb
# age.rb

puts "How old are you?"

age = gets.chomp.to_i

puts "In 10 years you will be: #{age + 10}"
puts "In 20 years you will be: #{age + 20}"
puts "In 30 years you will be: #{age + 30}"
puts "In 40 years you will be: #{age + 40}"

#+END_SRC

Here's the solution from the book. Mine's a bit different, but both work. The main difference is that my solution prints each statement on one line, and the book's prints each solution two lines. 
#+BEGIN_SRC ruby
puts "How old are you?" 
age = gets.chomp.to_i 
"In 10 years you will be:" 
puts age + 10 
puts "In 20 years you will be:" 
puts age + 20 
puts "In 30 years you will be:" 
puts age + 30 
puts "In 40 years you will be:" 
puts age + 40
#+END_SRC
**** Note 
A couple things:
1. I learned about the 'to.i' method this summer. It seems to be the equivalent of JavaScript's 'parseInt'. I'll need to look into this more.
2. Are there any practical differences to the way I solved the problem, vs. the way the book did?

*** Problem 3
Add another section onto name.rb that prints the name of the user 10 times. You must do this without explicitly writing the puts method 10 times in a row.

*** Solution 3

*File:* [[file:03_variables/name2.rb]]

#+BEGIN_SRC ruby :tangle 03_variables/name2.rb
# 03_variables/name2.rb (Version II; prints out the greeting ten times)
puts "What is your name?" 
name = gets.chomp 

10.times do
  puts name
end
#+END_SRC

*** Book Solution (Same)

#+BEGIN_SRC ruby
  # name.rb continued 
  10.times do 
    puts name 
  end
#+END_SRC

*Comments*
Yay! I got this right. :)

*** Problem 4
Modify name.rb again so that it first asks the user for their first name, saves it into a variable, and then does the same for the last name. Then outputs their full name all at once.

*** Solution 4


**** Version 1
*File:* [[file:03_variables/name3_version1.rb][03_variables/name3_version1.rb]]

#+BEGIN_SRC ruby :tangle 03_variables/name3_version1.rb
# 03_variables/name3_version1.rb (Version III; prints out full name

puts "What is your first name?" 
first_name = gets.chomp

puts "What is your last name?" 
last_name = gets.chomp 

puts first_name + " " + last_name

#+END_SRC

**** Version 2
*File:* [[03_variables/name3_version2.rb]]

#+BEGIN_SRC ruby :tangle 03_variables/name3_version2.rb
# name.rb (Version III; prints out full name, with interpolation)

puts "What is your first name?" 
first_name = gets.chomp

puts "What is your last name?" 
last_name = gets.chomp 

puts "#{first_name} #{last_name}"

#+END_SRC


**** Book Solution
#+BEGIN_SRC ruby
# name.rb continued again
puts "What is your first name?"
first_name = gets.chomp
puts "Thank you. What is your last name?"
last_name = gets.chomp
puts "Great. So your full name is " + first_name + " " + last_name

#+END_SRC

**** Comments
I didn't have any problems with this one. My name3_version1.rb file is about the same as the book's verison; name2_version2.rb uses string interpolation to achieve the same result.

*** Problem 5
Look at the following programs...

#+BEGIN_SRC ruby
  x = 0
  3.times do
    x += 1
  end
  puts x
#+END_SRC

and...

#+BEGIN_SRC ruby

  y = 0
  3.times do
    y+= 1
    x = y
  end
  puts x

#+END_SRC
What does x print to the screen in each case? Do they both give errors? Are the errors different? Why?

**** My Solution
*Here are my guesses before I test them...*
I think the first one will print '3', because 'X' is defined as '0', and then it is incremented three times. Because the variable is initialized globally, it will be available in the global scope.

X will cause an error in the second example, because 'x' is initialized within the '3.times do' local scope. (BTW, Y = 1)...

And now for the tests...

- I was right for the first one.

- I was also right for the second one. The exact error message was:

  #+BEGIN_SRC sh
test.rb:6:in `<main>': undefined local variable or method `x' for main:Object (NameError)
  
  #+END_SRC

*Here's the book's solution:*
The first prints 3 to the screen. The second throws an error undefined local variable or method because x is not available as it is created within the scope of the do/end block.

*Comments*
I was right, but I should have been a bit more precise with my answer for the second one. The nature of the error was 'undefined local variable or method.'

*** Problem 6
What does the following error message tell you?

#+BEGIN_SRC ruby
NameError: undefined local variable or method `shoes' for main:Object

from (irb):3

from /usr/local/rvm/rubies/ruby-2.0.0-rc2/bin/irb:16:in `<main>'

#+END_SRC

*** Solution 6
The variable 'shoes' was defined locally, and is therefore unavailable in the global scope.

*Here's the book's solution:*
"The program is trying to reference a variable or method named shoes that has not been defined in the program, or is outside of the scope in which it is being called."

* Methods

** What Are Methods and Why Do We Need Them?
- Most programming languages have procedures that allow you to abstract function calls (or other tasks), to make code cleaner and more readable. In Ruby, these are called *methods*.
- We can add parameters(x) to access data from outside the current scope.
  - Like variables, parameters should always have clear and easily-understandable names.
  - Parameters allow us to pass values into methods, which can allow us to make changees in one place, which can change many other parts of our code, as we'll see below.

Here is the basic syntax:
#+BEGIN_SRC ruby
  
  def say
    # method body goes here
  end
  
#+END_SRC

Using a method call, we can turn this redundant code:
#+BEGIN_SRC ruby

# say.rb

puts "hello"
puts "hi"
puts "how are you"
puts "I'm fine"

#+END_SRC

into this:

#+BEGIN_SRC ruby
    
    # say.rb refactored
    def say(words)
      puts words
    end

    say("hello")
    say("hi")
    say("how are you")
    say("I'm fine")
    
#+END_SRC

One advantage of using methods is that we can make a single change, which will make many changes in our program. For example, to add a period to each expresison:

#+BEGIN_SRC ruby
# say.rb refactored
def say(words)
puts words + '.' ## <= We only make the change here!
end
say("hello")
say("hi")
say("how are you")
say("I'm fine")

#+END_SRC

*** Aside
Taking this a step further, in irb, I grabbed the full array of available methods for strings:

#+BEGIN_SRC ruby
irb(main):001:0> "hello".methods.sort

=> [:!, :!=, :!~, :%, :*, :+, :<, :<<, :<=, :<=>, :==, :===, :=~, :>, :>=, :[], :[]=, :__id__, :__send__, :ascii_only?, :b, :between?, :bytes, :bytesize, :byteslice, :capitalize, :capitalize!, :casecmp, :center, :chars, :chomp, :chomp!, :chop, :chop!, :chr, :class, :clear, :clone, :codepoints, :concat, :count, :crypt, :define_singleton_method, :delete, :delete!, :display, :downcase, :downcase!, :dump, :dup, :each_byte, :each_char, :each_codepoint, :each_line, :empty?, :encode, :encode!, :encoding, :end_with?, :enum_for, :eql?, :equal?, :extend, :force_encoding, :freeze, :frozen?, :getbyte, :gsub, :gsub!, :hash, :hex, :include?, :index, :insert, :inspect, :instance_eval, :instance_exec, :instance_of?, :instance_variable_defined?, :instance_variable_get, :instance_variable_set, :instance_variables, :intern, :is_a?, :kind_of?, :length, :lines, :ljust, :lstrip, :lstrip!, :match, :method, :methods, :next, :next!, :nil?, :object_id, :oct, :ord, :partition, :prepend, :private_methods, :protected_methods, :public_method, :public_methods, :public_send, :remove_instance_variable, :replace, :respond_to?, :reverse, :reverse!, :rindex, :rjust, :rpartition, :rstrip, :rstrip!, :scan, :scrub, :scrub!, :send, :setbyte, :singleton_class, :singleton_method, :singleton_methods, :size, :slice, :slice!, :split, :squeeze, :squeeze!, :start_with?, :strip, :strip!, :sub, :sub!, :succ, :succ!, :sum, :swapcase, :swapcase!, :taint, :tainted?, :tap, :to_c, :to_enum, :to_f, :to_i, :to_r, :to_s, :to_str, :to_sym, :tr, :tr!, :tr_s, :tr_s!, :trust, :unpack, :untaint, :untrust, :untrusted?, :upcase, :upcase!, :upto, :valid_encoding?]

#+END_SRC

Then I capitalized each sentence:

#+BEGIN_SRC ruby
# say.rb refactored (plus, capitalized!)
def say(words)
  puts words.capitalize + "." # <= I added the 'capitalize' method, just for fun...
end

say("hello")
say("hi")
say("how are you")
say("I'm fine")

#+END_SRC

Here's the result:

#+BEGIN_SRC bash

Hello.
Hi.
How are you.
I'm fine.

#+END_SRC

*Learning to program is so much fun! :)* 

** Default Parameters
Default parameters allow us to write methods that work, even if no arguments are sent:

*File:* [[file:04_methods/say_refactored.rb][04_methods/say_refactored.rb]]
#+BEGIN_SRC ruby :tangle 04_methods/say_refactored.rb
  
  def say(words='hello')
    puts words + '.'
  end
  say()   # <= "hello."
  say("hi")
  say("how are you")
  say("I'm fine")
  
#+END_SRC

It works!

#+BEGIN_SRC sh
小A曰:ruby say_refactored.rb 
hello.
hi.
how are you.
I'm fine.
#+END_SRC

** Optional Parentheses
Many Rubyists leave off parentheses when using methods. So *say("hi")* could be written as *say "hi"*. This can make it hard to differentiate local variables and method names.

** obj.method or method(obj)
From the book:

"There are two ways to use methods that we will discuss in this book. The some_method(obj) format is when you send arguments to a method; in the previous example, obj is the argument being passed in to the some_method method. Sometimes, you will see methods called with an explicit caller, like this a_caller.some_method(obj). We will discuss this in more detail in part III on Object Oriented Programming. For now it's best to think of the previous code as some_method modifying a_caller. You'll have to memorize which way is required to call a method for now."

** Mutating the Caller (Permanently altering the argument)
Recall:
- method arguments are scoped
- method arguments are not available outside of the method
- methods cannot modify arguments permanently

*File:* [[file:04_methods/mutate.rb][04_methods/mutate.rb]]

#+BEGIN_SRC ruby :tangle 04_methods/mutate.rb
  def some_method(number)
    number = 7 # this is implicitly returned by the method (because it's scoped, it won't affect the global value of a).
  end
  
  a = 5
  some_method(a)
  puts a # <= '5'
  
  # a = 5
#+END_SRC


*** Aside
Just to test out what would happen, I made a change to the code on line 7. I added a 'puts' before 'some method(a), which allowed Ruby to print both the value of 'a' as an argument of *some_method* and as a global variable.

*File:* [[file:04_methods/mutate_test.rb][04_methods/mutate_test.rb]]
#+BEGIN_SRC ruby :tangle 04_methods/mutate_test.rb
  def some_method(number)
    number = 7 # this is implicitly returned by the method (because it's scoped, it won't affect the global value of a).
  end
  
  a = 5
  puts some_method(a) # <= I added a 'puts' here so that I could see the '7' 
  puts a # <= '5'
  
  # a = 5
#+END_SRC

*There is an exception to the rule!* We can perform actions that permanently change the argument (mutate the caller). For example:

*File:* [[file:04_methods/mutate_perm.rb][04_methods/mutate_perm.rb]]

#+BEGIN_SRC ruby :tangle 04_methods/mutate_perm.rb
# Example of a method that modifies its argument permanently
# 04_methods/mutate_perm.rb
a = [1, 2, 3]
def mutate(array)
  array.pop
end

p "Before mutate method: #{a}"
mutate(a)
p "After mutate method: #{a}"

# Result:
# "Before mutate method: [1, 2, 3]"
# "After mutate method: [1, 2]"

#+END_SRC

*** Comments
The authors point out that they use *p* instead of *puts* in this program. I ran it both ways, and here were the results:

**** *p*
"Before mutate method: [1, 2, 3]"

"After mutate method: [1, 2]"

**** *puts*
Before mutate method: [1, 2, 3]

After mutate method: [1, 2]

I spent some time learning at RubyMonk this summer, and I knew I'd seen a lesson about the difference between 'p' and 'puts'. The vernerable master explains, "*Puts* generally prints the result of applying to_s on an object while *p* prints the result of inspecting the object.

In other words, using 'p' is generally better for debugging, because it inspects the object..."p foo" is the same as "puts foo.inspect" (Source: http://stackoverflow.com/questions/1255324/p-vs-puts-in-ruby).

*** This method will not mutate the caller
#+BEGIN_SRC ruby
  # Example of a method that does not mutate the caller
  # mutate.rb
  
  a = [1, 2, 3]
  def no_mutate(array)
    array.last
  end
  
  p "Before no_mutate method: #{a}"
  no_mutate(a)
  p "After no_mutate method: #{a}"

# Results:
# "Before no_mutate method: [1, 2, 3]"
# "After no_mutate method: [1, 2, 3]"
  
#+END_SRC

Key points:
- The *last* method does not mutate the caller
- Some methods mutate the caller, and some do not. Unfortunately, you just have to memorize which do.
- Ruby is both a /pass-by-value/ and a /pass-by-reference/ language.
  
** puts vs. return: The Sequel

*File:* [[file:04_methods/mutate_sequel.rb][04_methods/mutate_sequel.rb]]
#+BEGIN_SRC ruby :tangle 04_methods/mutate_sequel.rb
# 04_methods/mutate_sequel.rb

a = [1, 2, 3]

def mutate(array)
  array.pop
end

p "Before mutate method:#{a}"    # a = [1, 2, 3]
p mutate(a)                      # 3 (popped value from array)
p "After mutate method:#{a}"     # a = [1, 2]
#+END_SRC

*Output*
#+BEGIN_SRC sh
小A曰:ruby mutate_sequel.rb 
"Before mutate method:[1, 2, 3]"
3
"After mutate method:[1, 2]"
#+END_SRC

Explanation:
1. Print out *a* as initially defined ([1,2,3] array)
2. Print out the value returned by the mutate method (array.pop)
3. Print out *a* afer the mutate method


Here's an example of *return*:

*File:* [[file:04_methods/return.rb][04_methods/return.rb]]
#+BEGIN_SRC ruby :tangle 04_methods/return.rb
# return.rb
def add_three(number)
number + 3
end

returned_value = add_three(4)
puts returned_value
#+END_SRC


I guessed it would be '7' and I was right!

Explanation from the book:

"Here we're saving the returned value of the add_three method in a variable called returned_value. Then we print returned_value to the output to see what it has inside it. Your output should print 7 because that's what the method returned."

"*Ruby methods ALWAYS return the evaluated result of the last line of the expression unless an explicit return comes before it.*" For example:
*File:* [[file:04_methods/return2.rb][04_methods/return2.rb]]
#+BEGIN_SRC ruby :tangle 04_methods/return2.rb

# return.rb
def add_three(number)
  return number + 3
end

returned_value = add_three(4)
puts returned_value

#+END_SRC

Output:

#+BEGIN_SRC sh
小A曰:ruby return2.rb 
7
#+END_SRC
*Comments*
I predicted the above formula would return 7. Return prints the value and stops without executing the next line.

*** Important Takeaway
Important feature of Ruby:
*"The 'return' reserved word is not required in order to return something from a method."

#+BEGIN_SRC ruby
    
  def just_assignment(number)
    foo = number + 3
  end

# The value of just_assignment(5) would be '8'
    
#+END_SRC

** Exercises

*** Problem 1
Write a program that contains a method called greeting that takes a name as its parameter. It then prints a greeting message with the name included in it.

*** Solution 1

*File:* [[file:04_methods/greeting.rb][04_methods/greeting.rb]]
#+BEGIN_SRC ruby :tangle 04_methods/greeting.rb
# 04_methods/greeting.rb

puts "What is your name?"
name = gets.chomp

def greeting(name)
  "Hello, " + name + "!" 
end

puts greeting(name)
#+END_SRC

*** Book Solution
#+BEGIN_SRC ruby
def greeting(name)
"Hello, " + name + ". How are you doing?"
end
puts greeting("Bob")

#+END_SRC


*Comments*
My version worked, but I focused on making it interactive, instead of on passing in an argument.

Here's a version that combines my solution with the authors':

*File:* [[file:04_methods/greeting_final.rb][04_methods/greeting_corrected.rb]]
#+BEGIN_SRC ruby :tangle 04_methods/greeting_corrected.rb

def greeting(name)
  "Hello, " + name + ". I think Ruby's pretty cool. How about you?"
end

puts greeting("Jon")
#+END_SRC


** Problem 2.
What do the following expressions evaluate to?

#+BEGIN_SRC ruby

1. x = 2
2. puts x = 2
3. p name = "Joe"
4. four = "four"
5. print something = "nothing"

#+END_SRC

** Solution 2

1. x will equal 2, but it won't print anything. 2
2. x will equal two, and it will evaluate to "2" and return nil
3. "Joe"
4. four will equal the string "four", but it won't print anything.
5. nothing
   
*** Book Solution
#+BEGIN_SRC ruby
1. x = 2 # => 2
2. puts x = 2 # nil
3. p name = "Joe" # => "Joe"
4. four = "four" # => "four"
5. print something = "nothing" # => nil

  #+END_SRC

#+BEGIN_SRC sh
print something = "nothing"

#+END_SRC

*** Solution 2

1. x will equal 2, but it won't print anything. 2
2. x will equal two, and it will evaluate to "2" and return nil
3. "Joe"
4. four will equal the string "four", but it won't print anything.
5. nothing
   
*** Book Solution
#+BEGIN_SRC ruby
1. x = 2 # => 2
2. puts x = 2 # nil
3. p name = "Joe" # => "Joe"
4. four = "four" # => "four"
5. print something = "nothing" # => nil

#+END_SRC

Just to be sure, I ran these through irb:

#+BEGIN_SRC sh

irb(main):002:0> x = 2
x = 2
=> 2
irb(main):003:0> puts x = 2
puts x = 2
2
=> nil
irb(main):004:0> "Joe"
"Joe"
=> "Joe"
irb(main):005:0> four = "four"
four = "four"
=> "four"
irb(main):006:0> print something
print something
nothing=> nil
irb(main):007:0> 

#+END_SRC

*** Problem 3
Write a program that includes a method called multiply that takes two arguments and returns the product of the two numbers.

*** Solution 3

*File:* [[file:04_methods/multiply.rb][04_methods/multiply.rb]]
#+BEGIN_SRC ruby :tangle 04_methods/multiply.rb

def multiply(a, b)
  a * b
end

puts multiply(5,3)

#+END_SRC

*** Book Solution

#+BEGIN_SRC ruby
  
  def multiply(number1, number2) 
    number1 * number2 
  end 
  puts multiply(4, 2)
  
#+END_SRC

*** Comments
My solution worked, and it was essentially the same thing, but I used 'a' and 'b' for arguments. 'number1' and 'number2' are more descriptive and would probably be better choices for arguments.

** Problem 4
What will the following code print to the screen?

#+BEGIN_SRC ruby
  def scream(words)
    words = words + "!!!!"
    return puts words
  end

  scream("Yippeee") 
  
#+END_SRC

*** Andrew's Answer
Nothing. When it hits the 'return' on the third line, it will stop evaluating the program.

*** Book Solution
It will not print anything to the screen. This is great, because I'm used to looking for the 'return' now, and when I see it, I know that nothing after it will be printed.


** Problem 5
1) Edit the method in exercise #4 so that it does print words on the screen;
2) What does it return now?

*** Andrew's Answer
My guess before I do anything is that if I remove (or simply comment out) the 'return', it will return "Yipeee!!!!" Let's try:


1. *File:* [[file:04_methods/scream.rb][04_methods/scream.rb]]

#+BEGIN_SRC ruby :tangle 04_methods/scream.rb

def scream(words)
  words = words + "!!!!"
#  return
  puts words
end

scream("Yippeee")

#+END_SRC

2. It should print out "Yippeee!!!!"

*** Book Solution

1.
#+BEGIN_SRC ruby

def scream(words)
words = words + "!!!!"
puts words
end
scream("Yippeee")

#+END_SRC

2. still returns *nil*

The key here is that it /prints/ "Yippeee!!!!" but it /returns/ nil. Watching the *Video Walkthrough* made this clear to me. In irb:

#+BEGIN_SRC ruby
小A曰:irb
irb(main):001:0> def scream(words)
irb(main):002:1> words = words + "!!!!"
irb(main):003:1> puts words
irb(main):004:1> end
=> :scream
irb(main):005:0> scream("Yippeee")
Yippeee!!!!  # <= Prints "Yippeee!!!!"
=> nil       # <= Returns nil

# In this case, if we add a 'hi there' string to the end of the method, Ruby will return that string, regardless of what is printed.
irb(main):006:0> def scream(words)
irb(main):007:1> words = words + "!!!!"
irb(main):008:1> puts words
irb(main):009:1> 'hi there'
irb(main):010:1> end
=> :scream
irb(main):011:0> scream("Yippeee")
Yippeee!!!!    # <= Prints "Yippeee!!!!"
=> "hi there"  # <= Returns "hi there"

#+END_SRC

*Comments*

Aha! The light bulb finally went off for me when I watched the video, and the instructor said, "In Ruby methods, the last thing in the method is the 'return' value, regardless what happens in the method (except for the return keyword.) We've already seen that the return keyword is not necessarily needed in Ruby, but it is needed when we need to explicitly designated a return value, (.e.g., in a conditional statement).

*Keypoint:* Every Ruby program returns something, even if it's only a 'nil'.


In the example, he added 'hi there' before the 'end' statement, and Ruby returned that. Now I understand that Ruby can put/print a value, but still return 'nil'! (And that's what I've been seeing in irb all along!)

** 6. What does the following error message tell you?

#+BEGIN_SRC sh
ArgumentError: wrong number of arguments (1 for 2)
from (irb):1:in `calculate_product\
from (irb):4
from /Users/username/.rvm/rubies/ruby-2.0.0-p353/bin/irb:12:in `<main>'

#+END_SRC

*** Solution 6
In a method called 'calculate_product, only one argument was given, but two were required.
*** Book Solution
You are calling a method (calculate_product in this case) that requires two arguments, but you are only providing one.

* Flow Control
** Conditionals

*** Formed with a combination of logical statments and comparison operators.
Logical Statements:
- if
- else
- elsif
- end

Comparison Operators:
- <
- >
- <=
- >=
- !=
- &&
- ||

*File:* [[05_flow_control/conditional.rb]]  
#+BEGIN_SRC ruby :tangle 05_flow_control/conditional.rb
# 05_flow_control/conditional.rb

puts "Put in a number"
a = gets.chomp.to_i
if a == 3
  puts "a is 3"
elsif a == 4
  puts "a is 4"
else
  puts "a is neither 3, nor 4"
end

#+END_SRC
*Output*
#+BEGIN_SRC sh
小A曰:ruby conditional.rb 
Put in a number
3
a is 3
小A曰:ruby conditional.rb 
Put in a number
4
a is 4
小A曰:ruby conditional.rb 
Put in a number
9
a is neither 3, nor 4

#+END_SRC

*** Valid Ruby Conditionals
#+BEGIN_SRC ruby
# Example 1
  if x == 3
    puts "x is 3"
  end
  
#+END_SRC

#+BEGIN_SRC ruby
# Example 2
  if x == 3
    puts "x is 3"
  elsif x == 4
    puts "x is 4"
  end
  
#+END_SRC

#+BEGIN_SRC ruby
# Example 3
  if x == 3
    puts "x is 3"
  else
    puts "x is NOT 3"
  end
  
#+END_SRC

#+BEGIN_SRC ruby
# Example 4: must use "then" keyword when using 1-line syntax

if x == 3 then puts "x is 3" end

# or

puts "x is 3" if x == 3

#+END_SRC

*unless* is a reserved word that serves as the opposite of *if*:

#+BEGIN_SRC ruby
puts "x is NOT 3" unless x ==3

#+END_SRC

*** Comparisons
- *Key Point*: Comparisons always return a *boolean value*.

  | Symbol | Meaning                  | Comments   |
  |--------+--------------------------+------------|
  | <      | less than                |            |
  | >      | greater than             |            |
  | <=     | less than or equal to    |            |
  | >=     | greater than or equal to |            |
  | ==     | equal to                 | (no '===') |
  | !=     | not equal to             |            |
  | &&     | and                      |            |
  |        | or                       |            |


**** Less than/Greater than

#+BEGIN_SRC ruby
irb(main):022:0> 4 < 5
4 < 5
=> true
irb(main):023:0> 4 > 5
4 > 5
=> false
#+END_SRC

**** Less than or equal to/Greater than or equal to
#+BEGIN_SRC ruby
irb(main):024:0> 4 <= 5
4 <= 5
=> true
irb(main):025:0> 5 >= 5
5 >= 5
=> true
irb(main):026:0> 4 >= 5
4 >= 5
=> false
irb(main):027:0> 4 >= 3
4 >= 3
=> true
irb(main):028:0> 4 >= 4
4 >= 4
=> true

#+END_SRC

**** Is equal to
#+BEGIN_SRC ruby
irb(main):029:0> 5 == 5
5 == 5
=> true
irb(main):030:0> 5 == 6
5 == 6
=> false
irb(main):031:0> '5' == 5
'5' == 5
=> false
#+END_SRC
*Note:* '5' is a string, and that is not equal to an integer (5). You must always compare the same type of data, or you'll get a 'false' boolean value.

**** Is not equal to
#+BEGIN_SRC ruby
irb(main):032:0> 4 != 5
4 != 5
=> true
irb(main):033:0> 4 != 4
4 != 4
=> false
irb(main):034:0> 4 != 156
4 != 156
=> true
#+END_SRC

*** Combining Expressions
1. && 'and' (Expressions on both the right and left of the operator must be true)
   #+BEGIN_SRC ruby
(4 == 4) && (5 == 5)
=> true

(4 == 5) && (5 == 5)
=> false

(4 == 5) && (5 == 6)
=> false
   
   #+END_SRC

2. The "or" Operator (An expression on either side of the operator must be true, or the value will be 'false'.)

   #+BEGIN_SRC ruby
(4 == 4) || (5 == 5)
=> true

(4 == 5) || (5 == 5)
=> true

(4 == 5) || (5 == 6)
=> false
   
   #+END_SRC

3. The "not" Operator (Putting this in front of a boolean expression will negate it.)

#+BEGIN_SRC ruby
!(4 == 4)
=> false
#+END_SRC

** Order of Precedence
1. <=, <, >, >= *Comparison*
2. ==, != *Equality*
3. && *Logical AND*
4. || *Logical OR*

How will the following be evaluated?   
   #+BEGIN_SRC ruby

if x && y || z
# do something
end
   
   #+END_SRC
Answer:
1. if *x && y* = true, *#do something* will be executed.
2. if *x && yY = false, the program will evaluate *|| z*. If true, *#do something* will be executed. If not, the *if* statement will be exited.

** Ternary Operator
- common Ruby idiom to make a quick *if/else* statement in one line.
- Uses a combination of *?* and *:*
- Ruby evaluates the expression to the left of the *?*.
  - If true, it executes the code directly after the *?*.
  - If false, it executes the code directly after the *:*. 

#+BEGIN_SRC ruby
true ? "this is true" : "this is not true"
=> true

false ? "this is true" : "this is not true"
=> false
#+END_SRC

** Case Statement
- Similar to 'if' statements
- Use *reserved words*:
  - *case*
  - *when*
  - *else*
  - *end*
- First define a case and then evaluate the value of the case and what operation to complete if the case is true...
- Modified version of *if/elsif/else* statement

*Here's an example:*

*File:* [[file:05_flow_control/case_statement.rb][05_flow_control/case_statement.rb]]
  #+BEGIN_SRC ruby :tangle 05_flow_control/case_statement.rb
    # case_statement.rb
    a = 5

    case a
    when 5
      puts "a is 5"
    when 6
      puts "a is 6"
    else
      puts "a is neither 5, nor 6"
    end
      
  #+END_SRC

  We can also save the result of a case statement into a variable, which will allow us to not have to write *puts* so many times.

  Here is the refactored file:

  *File:* [[http:05_flow_control/case_statement_refactored.rb%20][05_flow_control/case_statement_refactored.rb]]

  #+BEGIN_SRC ruby :tangle 05_flow_control/case_statement_refactored.rb
# 05_flow_control/case_statement_refactored.rb

a = 5

answer = case a
  when 5 
    "a is 5"
  when 6 
    "a is 6"
  else 
    "a is neither 5, nor 6"
  end

puts answer
  
  #+END_SRC

You can write the same program without a case argument:
*File:* [[file:05_flow_control/case_statement-refactored_no_case_argument.rb][05_flow_control/case_statement-refactored_no_case_argument.rb]]
#+BEGIN_SRC ruby :tangle
# 05_flow_control/case_statement-refactored_no_case_argument.rb
  
  a = 5 
  
  answer = case 
    when a == 5 
      "a is 5" 
    when a == 6 
      "a is 6" 
    else 
      "a is neither 5, nor 6" 
    end 

puts answer
  
#+END_SRC

** True and False
After *if* and *elsif*, we must put an expression that evaluates a boolean value:

#+BEGIN_SRC ruby
      
      a = 5
      if a 
        puts "how can this be true?"
        
      else
  
        puts "it is not true"
  
      end

# output: "how can this be true?"
      
#+END_SRC

We could also write this:
#+BEGIN_SRC ruby
if x = 5 # <= careful, this is not asking 'if x == 5...'; it's assigning the value 'x = 5'
  puts "how can this be true?"
else
  puts "it is not true"
end

#output: "How can this be true?"
#+END_SRC

** Exercises

*** Problem 1
Write down whether the following expressions return true or false. Then type the expressions into irb to see the results.

1. (32 * 4) >= 129
2. false != !true
3. true == 4
4. false == (847 == '874')
5. (!true || (!(100 / 5) == 20) || ((328 / 4) == 82)) || false

*** Solution 1
1. False. 128 isn't greater than or equal to 129.
2. False. False does not /not equal/ true. remove one of the exclamation marks.
3. false. true == true. 4 == 4.
4. true. the statement in parentheses is false.
5. true.
   
*** Book Solution
1. false
2. false
3. false
4. true
5. true

I got them all right!

*** Problem 2
Write a method that takes a string as argument. The method should return the capitalized version of the string, only if the string is longer than 10 characters. (Hint: Ruby's String class has a few methods that would be helpful. Check the [[http://ruby-doc.org/core-2.1.0/String.html][Ruby Docs]]!)

*** Solution 2

*File:* [[file:05_flow_control/string.rb][05_flow_control/capitalize.rb]]
#+BEGIN_SRC ruby :tangle 05_flow_control/capitalize.rb
      def capital(string)
        if string.length > 10
          puts string.upcase!
        else
          puts "You expect me to capitalize #{string}? I don't waste my time capitalizing such short words!"
        end
      end

      capital("it's not a tumor!")
      capital("hey")
#+END_SRC

*** Book Solution
#+BEGIN_SRC ruby
  
  # caps_method.rb
  def caps(string)
    if string.length > 10
      string.upcase
    else string
    end
  end

  puts caps("Joe Smith")
  puts caps("Joe Robertson")
  
#+END_SRC

*** Andrew's Comments
My solution was overly complicated. 'else string' is a lot more elegant. Also, not sure if there's a problem with 'puts' in line 3. Though mine would be good if I wanted to create a custom reply..

*** Problem 3
Write a program that takes a number from the user between 0 and 100 and reports back whether the number is between 0 and 50, 50 and 100, or above 100.

*** Andrew's Solution 3

*File:* [[file:05_flow_control/evaluate_num.rb][05_flow_control/evaluate_num.rb]]
#+BEGIN_SRC ruby :tangle 05_flow_control/evaluate_num.rb
# This was my original attempt; I refined my answer with: 05_flow_control/evaluate_num_simplified.rb

puts "Please choose a number."

number = gets.chomp.to_i

if (number >= 0) &&  (number <= 50)
  puts "Your number is between 0 and 50."
elsif (number >= 50) && (number <= 100)
  puts "Your number is between 50 and 100."
else number >100
  puts "Your number is more than 100."
end

#+END_SRC

*** Book Solution

#+BEGIN_SRC ruby
  # evaluate_num.rb
  puts "Please enter a number between 0 and 100."
  number = gets.chomp.to_i
  if number < 0
    puts "You can't enter a negative number!"
  elsif number <= 50
    puts "#{number} is between 0 and 50"
  elsif number <= 100 puts "#{number} is between 51 and 100"
  else
    puts "#{number} is above 100"
  end
#+END_SRC



*Comments*
My solution was too complicated, and I didn't use interpolation. Let's try again:

*File:* [[file:05_flow_control/evaluate_num_simplified.rb][05_flow_control/evaluate_num_updated.rb]]

#+BEGIN_SRC ruby :tangle 05_flow_control/evaluate_num_updated.rb
    # 05_flow_control/evaluate_num_simplified.rb
        puts "Please enter a number between 0 and 100."
        number = gets.chomp.to_i
        if number < 0
          puts "You've entered a negative number. Please try again."
        elsif number <= 50
          puts "#{number} is between 0 and 50."
        elsif number <= 100
          puts "#{number} is between 51 and 100"
        else
          puts "#{number} is above 100"
        end
#+END_SRC

*** Problem 4
What will each block of code below print to the screen? Write your answer on a piece of paper or in a text editor and then run each block of code to see if you were correct.

#+BEGIN_SRC ruby
  # 1.
   '4' == 4 ? puts("TRUE") : puts("FALSE")
    
    # 2.
    x = 2
    if ((x * 3) / 2) == (4 + 4 - x - 3)
      puts "Did you get it right?"
    else
      puts "Did you?"
    end
    
  # 3.
  y = 9
  x = 10
  if (x + 1) <= (y)
    puts "Alright."
  elsif (x + 1) >= (y)
    puts "Alright now!"
  elsif (y + 1) == x
    puts "ALRIGHT NOW!"
  else puts "Alrighty!"
  end
    
#+END_SRC

**** Andrew's Answer
1. "FALSE"
2. "Did you get it right?"
3. "Alright now!"
**** Book Solution
(Same) I got it right!



*** Problem 5
Rewrite your program from exercise 3 using a case statement. Wrap each statement in a method and make sure they both still work.

*Book Solution*

#+BEGIN_SRC ruby :tangle 05_flow_control/evaluate_num_revisited.rb

# evaluate_num_revisited.rb

def evaluate_num(num)
  if num < 0
    puts "You can't enter a negative num!"
  elsif num <= 50
    puts "#{num} is between 0 and 50"
  elsif num <= 100
    puts "#{num} is between 51 and 100"
  else
    puts "#{num} is above 100"
  end
end

def evaluate_case1_num(num)
  case
  when num < 0
    puts "You can't enter a negative num!"
  when num <= 50
    puts "#{num} is between 0 and 50"
  when num <= 100
    puts "#{num} is between 51 and 100"
  else
    puts "#{num} is above 100"
  end
end

def evaluate_case2_num(num)
  case num
  when 0..50
    puts "#{num} is between 0 and 50"
  when 51..100
    puts "#{num} is between 51 and 100"
  else
    if num < 0
      puts "You can't enter a negative num!"
    else
      puts "#{num} is above 100"
    end
  end
end

puts "Please enter a number between 0 and 100."
number = gets.chomp.to_i

evaluate_num(number)
evaluate_case1_num(number)
evaluate_case2_num(number)

#+END_SRC

*Confession:*
I spent a lot of time trying to make this work, and all of my guesses were way off. I watched the video and retyped the solution a couple times, and it makes sense to me, but I think I need to try another one, to make sure. So here is a different take on Problem 5:

#+BEGIN_SRC ruby :tangle 05_flow_control/problem5_extra_practice.rb
# I had trouble figuring out 05_flow_control/evaluate_num.rb on my own, so I created a new version for practice.
# This program asks how your day was. The length of your answer determines the reply!
      def string_length(num)
        if num == 0
            puts "You have to give me something to work with, here."
        elsif num <= 10
          puts "You're not much with words, are you?"
        elsif num <= 20
          puts "You've got a lot to say."
        else
          puts "Sounds like you had quite a day!"
          end
      end
  
      def string_length_case1(num)
        case
          when num == 0
          puts "You have to give me something to work with, here."
          when num <= 10
          puts "You're not much with words, are you?"
          when num <=20
          puts "You've got a lot to say."
        else
          puts "Sounds like you had quite a day!"
        end
      end
  
      def string_length_case2(num)
        case num
          when 1..10
          puts "You're not much with words, are you?"
          when 11..20
          puts "You've got a lot to say."
          else
          if num == 0
            puts "You have to give me something to work with, here."
          else
            puts "Sounds like you had quite a day!"
          end
        end
      end
  
  puts "Tell me about your day."
  number = gets.chomp.to_s.length
  
  string_length(number)
  string_length_case1(number)
  string_length_case2(number)
    
#+END_SRC

*Comment:* That helped. I understand the difference much better. I'm sure I'll be doing lots of extra problems as I go along, just to make sure I'm grasping the material...
*** Problem 6
When you run the following code...

#+BEGIN_SRC ruby 
    def equal_to_four(x)
      if x == 4
        puts "yup"
      else
        puts "nope"
      end
    
  equal_to_four(5)
        
#+END_SRC

You get the following error message..

#+BEGIN_SRC sh
test_code.rb:96: syntax error, unexpected end-of-input, expecting keyword_end

#+END_SRC
Why do you get this error and how can you fix it?

*** Solution 6
Based on the error messages I've seen so far, Ruby error messages usually seem to be farily easy to debug. In this case, it's missing an 'end' keyword. If we look at the code, the conditional is closed with an 'end' but the method is not (the 'def' is missing a closing 'end').

To fix this, just add one more 'end' at the end of the method, just before the last line, where it's called.

It should look like this:




#+BEGIN_SRC ruby :tangle 05_flow_control/equal_to_four.rb
    def equal_to_four(x)
      if x == 4
        puts "yup"
      else
        puts "nope"
      end
    end                # <= add an 'end' here to close the method.
  equal_to_four(5)
        
#+END_SRC

* Loops & Iterators

** A Simple Loop
- The simplest way to create a loop is to use the *loop* keyword.
- According to the authors, "*loop* takes a block, which is denoted by *{ ... }* or *do ... end*." ([[http://www.gotealeaf.com/books/ruby/read/loops_iterators#simpleloop][Source]])
- Loops execute code within blocks until a user intervenes
- There are two ways to stop a loop:
  1. Pressing *Ctrl-C* while the loop is running
  2. Inserting a *break* into the block

Here's an example of an infinite loop in Ruby (To stop it from running, press *Ctrl-C*):


#+BEGIN_SRC ruby :tangle no
  # Warning: This program creates an infinite loop, which will not stop until you press the Ctrl-C button!
  
  loop do
    puts "This will keep printing until you hit Ctrl+ C"
  end
#+END_SRC

As expected, this produces an infinite loop, that doesn't stop:

#+BEGIN_SRC sh
This will keep printing until you hit Ctrl + c
This will keep printing until you hit Ctrl + c
This will keep printing until you hit Ctrl + c
This will keep printing until you hit Ctrl + c
This will keep printing until you hit Ctrl + cInterrupt:
from (pry):2:in `puts'
[2] pry(main)>
#+END_SRC

** Controlling Loop Execution
Of course, it's more useful to control loops with the *break* keyword, as in this example:

*File:* [[file:06_loops/useful.loop.rb][06_loops/useful.loop.rb]]
#+BEGIN_SRC ruby :tangle 06_loops/useful.loop.rb
  # 06_loops/useful.loop.rb
  
  i = 0
  loop do
    i += 2
    puts "#{i}"
    if i == 10
      break #this will cause execution to exit the loop
    end
  end
  #+END_SRC

*Output:*

#+BEGIN_SRC sh
ruby conditional_loop.rb

2
4
6
8
10
=> nil

#+END_SRC

As I'd expect, when the interation reached a value of '10', it stopped.

We can also use *next* to skip the rest of the current iteration and move to the next one. (This is different from *break*, because while *break* will exit the loop, *next* will move to the next iteration within the loop.)

*Example:*

#+BEGIN_SRC ruby 
# next_loop.rb

i = 0

loop do

  i += 2
  if i == 4
    next # skips the rest of the code for this iteration
  end
  puts "#{i}"
  if i == 10
    break
  end
end
#+END_SRC

*Output:*

#+BEGIN_SRC sh
ruby next_loop.rb

2
6
8
10
=> nil

#+END_SRC

The value of '4' was not printed out, because that iteration was skipped; the code picked up with the next value, and went until it was told to break at 10.

** While Loops
- Takes a parameter that evaluates to a boolean (true/false) value.
- Once the value of the boolean expression is *false*, the while loop is no longer executed.
- Any kind of logic is possible with a while loop.

This example counts down from any number the user provides:

*File:* [[file:06_loops/countdown.rb][06_loops/countdown.rb]]
#+BEGIN_SRC ruby :tangle 06_loops/countdown.rb
    # 06_loops/countdown.rb
  
    x = gets.chomp.to_i
  
    while x >= 0
      puts x
      x = x - 1
    end
    
    puts "Done!"
    
#+END_SRC

#+BEGIN_SRC sh
小A曰:ruby countdown.rb

5
4
3
2
1
0
Done!

#+END_SRC
This example shows how to write less code:


*File:* 06_loops/countdown_refactored.rb
#+BEGIN_SRC ruby :tangle 06_loops/countdown_refactored.rb
    # 06_loops/countdown_refactored.rb
    
    x = gets.chomp.to_i
    
    while x >= 0
      puts x
  x -= 1 # <-- Refactored line
    end

puts "Done!"
    
#+END_SRC

#+BEGIN_SRC sh
小A曰:ruby countdown.rb

5
4
3
2
1
0
Done!

#+END_SRC
I've seen this kind of thing in JavaScript.

Key Points:
- *x = x - 1* is the same as *x -= 1*
- This shortcut can be done with other operators, like (+, *, /, etc.)
- This kind of loop (x >= 0) requires that you act upon x, and also that you have a way to stop the loop, or it will become unresponsive and crash.

** Until Loops
- The until loop is the opposite of the while loop.
- The until loop is a convenience; sometimes it's easier or more elegant to write code this way.

Here's how it works:

*File:* [[file:06_loops/countdown_until.rb][06_loops/countdown_until.rb]]
#+BEGIN_SRC ruby :tangle 06_loops/countdown_until.rb
    # 06_loops/countdown_until.rb
    
    x = gets.chomp.to_i
    
    until x < 0
      puts x
      x -= 1
    end

puts "Done!"
    
#+END_SRC

*Output:*
#+BEGIN_SRC sh
小A曰:ruby countdown_until.rb

5
4
3
2
1
0
Done!

#+END_SRC
** Do/While Loops
- Similar to while loops, but the code within the loop is executed once first, and then the conditional check begins.
- The while statement is placed at the end of the loop.
- Do/While loops are descended from the C language. Instead of using the *do* keyword to begin the loop, we use *begin*.

  Here's an example:

  *File:* [[file:06_loops/countdown2.rb][06_loops/countdown2.rb]]
  #+BEGIN_SRC ruby :tangle 06_loops/countdown2.rb
    # 06_loops/countdown2.rb
    
    x = gets.chomp.to_i
    
    begin
      puts x
      x -= 1
    end while x >= 0

puts "Done!"
      
  #+END_SRC

  *Output:*
  #+BEGIN_SRC sh
小A曰:ruby countdown2.rb

5
4
3
2
1
0
Done!
  
  #+END_SRC
** For Loops
- For loops loop over a set collection of elements
- No risk of infinite loops; the first and last elements of the range are defined.
- begins with the *for* reserved word; then the *in* reserved word, and the elements.

  *File:* [[file:06_loops/countdown3.rb][06_loops/countdown3.rb]]
  #+BEGIN_SRC ruby :tangle 06_loops/countdown3.rb
        # 06_loops/countdown3.rb
        
        x = gets.chomp.to_i
        
        for i in 1..x do
          puts i
        end

puts "Done!"

  #+END_SRC

  *Output:*
  #+BEGIN_SRC sh
小A曰:ruby countdown3.rb

1
2
3
4
5
Done!
  
  #+END_SRC

This example uses arrays:

*File:* [[file:06_loops/countdown4.rb][06_loops/countdown4.rb]]
#+BEGIN_SRC ruby :tangle 06_loops/countdown4.rb
    # 06_loops/countdown4.rb
    x = [1, 2, 3, 4, 5]
    
    for i in x do
      puts i
    end
  
  puts "Done!"
#+END_SRC

** Conditionals Within Loops
Conditionals can improve loops by providing flow control and precision.

Here's an example that uses and 'if' statement and only prints odd numbers. Note the use of the *odd?* method to print only odd variables in the loop.:

*File:* [[file:06_loops/conditional_loop.rb][06_loops/conditional_loop.rb]]
#+BEGIN_SRC ruby :tangle 06_loops/conditional_loop.rb
  # 06_loops/conditional_loop.rb
  
  x = 0
  
  while x <= 10
    if x.odd?
      puts x
    end
    x += 1
  end
    #+END_SRC

*Output:*
#+BEGIN_SRC sh
小A曰:ruby conditional_loop.rb
1
3
5
7
9
#+END_SRC

Note the use of the reserved words *next* and *break* in the next two examples. Recall that *next* skips the current iteration and goes to the next one, and *break* stops the loop evaluation.

*File:* [[file:06_loops/conditional_loop_with_next.rb][06_loops/conditional_loop_with_next.rb]]
#+BEGIN_SRC ruby :tangle 06_loops/conditional_loop_with_next.rb
  # 06_loops/conditional_loop_with_next.rb
  
  x = 0
  
  while x <= 10
    if x == 3
      x += 1
      next
    elsif x.odd?
      puts x
    end
    x += 1
  end
  
#+END_SRC

*Output:*
#+BEGIN_SRC sh
小A曰:ruby conditional_loop_with_next.rb
1
5
7
9
#+END_SRC
The use of *next* in the code allowed us to avoid printing the number 3 in the loop. Here's an example with *break*:

#+BEGIN_SRC ruby :tangle 06_loops/conditional_loop_with_break.rb
    x = 0
  
  while x <= 10
    if x == 7
      break
    elsif x.odd?
      puts x
    end
    x+= 1
  end
    
#+END_SRC

*Output:*
#+BEGIN_SRC sh
小A曰:ruby conditional_loop_with_break.rb
1
3
5
#+END_SRC

** Iterators
- Iterators, according to the authors, "are methods that naturally loop over a given set of data and allow you to operate on each element in the collection." ([[http://www.gotealeaf.com/books/ruby/read/loops_iterators#iterators][Source]])
- Iterators provide a great deal of flexibilty, because they allow us to concisely print arrays and other data sources in an efficient format.
- Most Rubyists prefer iterators to loops.

*Here's an example that prints a list of array names:*

*File:* [[file:06_loops/practice_each.rb][06_loops/practice_each.rb]]
#+BEGIN_SRC ruby :tangle 06_loops/practice_each.rb
# 06_loops/practice_each.rb

names = ['Bob', 'Joe', 'Steve', 'Janice', 'Susan', 'Helen']

names.each { |name| puts name }
#+END_SRC

*Output:*
#+BEGIN_SRC sh
小A曰:ruby practice_each.rb
Bob
Joe
Steve
Janice
Susan
Helen
#+END_SRC

I'll paraphrase the book's explanation, because that helps me understand.

The *each* method, called by the '.' dot operator, loops through each element in the array, from 'Bob' to 'Helen.' It then evaluates the code in the block, which is defined within the curly braces, {}. The variable *|name|* is placed between two pipes. This is the value assigned to each element. Finally, each time the loop runs, the result is printed to the screen (*puts name*).

*Question:* Is the use of pipes the same as in Unix-based command line programs? (i.e., do the pipes direct data, or are they just dividers for the variable and the code?)

Blocks are simply code to be run. In Ruby, there are two things to remember about blocks:
1. We use curly braces ({}) for anything that can be contained in one line.
2. We use reserved words *do* and *end* for multi-line code blocks.

We can take the previous code, and add incremental line numbers:

*File:* [[file:06_loops/practice_each.rb][06_loops/practice_each.rb]]
#+BEGIN_SRC ruby :tangle 06_loops/practice_each.rb
    # 06_loops/practice_each.rb
    
    names = ['Bob', 'Joe', 'Steve', 'Janice', 'Susan', 'Helen']
    x = 1
    
    names.each do |name|
      puts "#{x}. #{name}"
      x += 1
    end
#+END_SRC

*Output:*
#+BEGIN_SRC sh
小A曰:ruby practice_each.rb
Bob
Joe
Steve
Janice
Susan
Helen
1. Bob
2. Joe
3. Steve
4. Janice
5. Susan
6. Helen
#+END_SRC

** Recursion
- another kind of loop
- calling a method within itself

  
  *Simple Example*

  Let's say you wanted to create a program that would continue to double the number. You could create it like this:
  
  *Example:*
  #+BEGIN_SRC ruby :tangle no
        
        def doubler(start)
          puts start * 2
        end
        
          
  #+END_SRC

Then, you could keep calling it from irb:

#+BEGIN_SRC ruby :tangle no
irb(main):001:0> def doubler(start)
irb(main):002:1>   puts start * 2
irb(main):003:1> end
=> :doubler
irb(main):004:0> doubler(2)
4
=> nil
irb(main):005:0> doubler(4)
8
=> nil
irb(main):006:0> doubler(8)
16
=> nil

#+END_SRC

But using recursion makes this task much simpler. For example:

#+BEGIN_SRC ruby :tangle no
      def doubler(start)
        puts start
        if start < 10
          doubler(start * 2)
        end
      end
      
#+END_SRC

Here's what that would do when it was run:

#+BEGIN_SRC ruby
irb(main):001:0> def doubler(start)
irb(main):002:1>   puts start
irb(main):003:1>   if start < 10
irb(main):004:2>     doubler(start * 2)
irb(main):005:2>   end
irb(main):006:1> end
=> :doubler
irb(main):007:0> doubler(2)
2
4
8
16
=> nil
#+END_SRC

** Another Example
We can use recursion to calculate the *nth number in the [[http://en.wikipedia.org/wiki/Fibonacci_number][fibonacci sequence]].

*File:* [[file:06_loops/fibonacci.rb][06_loops/fibonacci.rb]]

#+BEGIN_SRC ruby :tangle 06_loops/fibonacci.rb
  # 06_loops/fibonacci.rb
  
  def fibonacci(number)
    if number < 2
      number
    else
      fibonacci(number -1) + fibonacci(number - 2)
    end
  end

puts fibonacci(6)
#+END_SRC

Here's a really clear explanation of the fibonacci sequence. It starts off very simply, so be sure to watch the whole thing: http://www.youtube.com/watch?v=koFsRrJgioA

The authors offer a final word about recursion:

The key concept with recursion is that there is some baseline condition that returns a value, which then "unwinds" the recursive calls. You can think of the successive recursive calls building up, until some value is returned, and only then can the recursive calls be evaluated. ([[http://www.gotealeaf.com/books/ruby/read/loops_iterators#recursion][Source]])

** Exercises

*** Problem 1
What does the each method in the following program return after it is finished executing?

#+BEGIN_SRC ruby
    x = [1, 2, 3, 4, 5]
    x.each do |a|
      a + 1
    end
    
#+END_SRC

*** Solution 1
My guess is that this will increment each number in the array, adding +1 to the value of each integer ('a') like this:

#+BEGIN_SRC
2
3
4
5
6
#+END_SRC

Oh no! I fell for that trick again! I forgot the lesson I learned, back in *Chapter 5, Problem 2*:

#+BEGIN_SRC 
Aha! The light bulb finally went off for me when I watched the video, and the instructor said, "In Ruby methods, the last thing in the method is the 'return' value, regardless what happens in the method (except for the return keyword.) We've already seen that the return keyword is not necessarily needed in Ruby, but it is needed when we need to explicitly designated a return value, (.e.g., in a conditional statement).

*Keypoint:* Every Ruby program returns something, even if it's only a 'nil'.


In the example, he added 'hi there' before the 'end' statement, and Ruby returned that. Now I understand that Ruby can put/print a value, but still return 'nil'! (And that's what I've been seeing in irb all along!)
#+END_SRC

Actually, it returned the same array: [1, 2, 3, 4, 5]. I ran it through irb. I'm learning a lot, but I still have a long way to go...

*** Problem 2
Write a while loop that takes input from the user, performs an action, and only stops when the user types "STOP". Each loop can get info from the user.

#+BEGIN_SRC ruby 
    # 06_loops/exercise2.rb
    #Warning, this is an infinite loop!
x = 1

while x > 0
puts "I won't stop until you type 'STOP'"
end

puts "OK, I stopped!"


#+END_SRC

OK, I tried a few things. One of the things I tried was "while x != 'STOP'" and I had it loop. I deleted that one, and I thought this might work, but it wouldn't pause to let me stop it. Here's the book's answer:

#+BEGIN_SRC ruby
    # The Book's Answer (Exercise 2)
    
    x = ""
    
    while x != "STOP" do
      puts "Hi, How are you feeling?"
      ans = gets.chomp
      puts "What me to ask you again?"
      x = gets.chomp
    end
    
#+END_SRC

OK, after watching the video, it makes more sense. So let's try another one:

*File:* 06_loops/exercise2.rb
#+BEGIN_SRC ruby :tangle 06_loops/exercise2.rb
    # 06_loops/exercise2.rb
    # Runs a 'while' loop until the user types 'STOP'.
    x = ""
  
    while x != "STOP" do
      puts "Are you still hungry?"
      ans = gets.chomp
      puts "You don't mind if I eat your fries, do you?"
      x = gets.chomp
    end
#+END_SRC

*** Problem 3
Use the [[http://ruby-doc.org/core-2.1.0/Enumerable.html#method-i-each_with_index][each_with_index]] method to iterate through an array of your creation that prints each index and value of the array.
*** Solution 3

*File:* [[06_loops/exercise3.rb]]
 #+BEGIN_SRC ruby :tangle 06_loops/exercise3.rb
   # Lists Japanese Imperial Reign names since the end of the Edo Period.

   ["Meiji", "Taisho", "Showa", "Heian"].each_with_index do |item, index |
        puts "#{index + 1}: #{item}"
      end
#+END_SRC
I got a lot of help for this from this [[http://stackoverflow.com/questions/20258086/difference-between-each-with-index-and-each-with-index-in-ruby][Stack Overflow discussion]].

Here's the book's solution:

#+BEGIN_SRC ruby
top_five_games = ["mario brothers",
                  "excite bike",
                  "ring king",
                  "castlevania",
                  "double dragon"]

top_five_games.each_with_index do | game, index |
  puts "#{index + 1}. #{game}"
end
#+END_SRC

I like adding one to the index to make it a "normal" list. I'll add that to mine.

*** Problem 4
Write a method that counts down to zero using recursion.
*** Solution 4

*File:* [[06_loops/exercise4.rb]]
#+BEGIN_SRC ruby :tangle 06_loops/exercise4.rb
    # 06_loops/exercise4.rb
    # Uses recursion to count down to zero
    
    def final_countdown(x)
      if x == 0
        return
        else
        puts x
        final_countdown(x-1)
      end
    end
  
  final_countdown(10)
#+END_SRC

Here's the book's answer:
#+BEGIN_SRC ruby
def count_to_zero(number)
  if number <= 0
    puts number
  else
    puts number
    count_to_zero(number-1)
  end
end

count_to_zero(10)
count_to_zero(20)
count_to_zero(-3)
#+END_SRC

In the video, he said that we should always think the stop condition when we think about recursion.

In my example, I used 'return' to stop the recursion, so it didn't print '0' To fix this, I could rewrite it to look like the book's:

*File:* [[file:06_loops/exercise4_without_return.rb][06_loops/exercise4_refactored.rb]]
#+BEGIN_SRC ruby :tangle 06_loops/exercise4_refactored.rb
        # 06_loops/exercise_refactored.rb
        # Uses recursion to count down to zero
        # Refactored to print '0' in the countdown
        
        def final_countdown(x)
          if x <= 0
            puts x
            else
            puts x
            final_countdown(x-1)
          end
        end
      
      final_countdown(10)
#+END_SRC

That worked. And now, we're ready to work on Arrays!

* Arrays
- Ordered lists of elements
- can be of any type: [1, 'Bob', 4.33, 'another string']

  #+BEGIN_SRC ruby
irb(main):001:0> [1, 'Bob', 4.33, 'another string']
[1, 'Bob', 4.33, 'another string']
=> [1, "Bob", 4.33, "another string"]
  
  #+END_SRC

We can assign the array to a variable:

#+BEGIN_SRC ruby
irb(main):002:0> my_array = [1, 'Bob', 4.33, 'another string']
my_array = [1, 'Bob', 4.33, 'another string']
=> [1, "Bob", 4.33, "another string"]
irb(main):003:0> my_array
my_array
=> [1, "Bob", 4.33, "another string"]

#+END_SRC

To get the first element, we can use the *first* method:

#+BEGIN_SRC ruby
irb(main):004:0> my_array.first
my_array.first
=> 1
#+END_SRC

Or the *last*:

#+BEGIN_SRC ruby
irb(main):005:0> my_array.last
my_array.last
=> "another string"
#+END_SRC

We can also reference items by their index number (remember that Ruby, like many languages, starts with '0'):

#+BEGIN_SRC ruby

irb(main):006:0> my_array[3]
my_array[3]
=> "another string"

irb(main):007:0> my_array[2]
my_array[2]
=> 4.33

irb(main):008:0> my_array[1]
my_array[1]
=> "Bob"

irb(main):009:0> my_array[0]
my_array[0]
=> 1

#+END_SRC

Just like JavaScript. :)

** Modifying Arrays

*** The *pop* and *<<* *(shovel)* methods
To remove an item from the array permanently, use the *pop* method:

#+BEGIN_SRC ruby
irb(main):010:0> my_array.pop
my_array.pop
=> "another string"

irb(main):013:0> my_array
my_array
=> [1, "Bob", 4.33]  # "another string" has been popped.
#+END_SRC

*This is an example of a method that mutates the caller.*

Not to worry; you can add the item back with the *push* method:

#+BEGIN_SRC ruby
irb(main):015:0> my_array.push("another string")
my_array.push("another string")
=> [1, "Bob", 4.33, "another string"]

irb(main):018:0> my_array
my_array
=> [1, "Bob", 4.33, "another string"]
#+END_SRC

Or you could use the *shovel* method (<<):

#+BEGIN_SRC ruby
irb(main):018:0> my_array
my_array
=> [1, "Bob", 4.33, "another string"]

irb(main):020:0> my_array.pop
my_array.pop
=> "another string"

irb(main):022:0> my_array
my_array
=> [1, "Bob", 4.33]

irb(main):024:0> my_array << "another string"
my_array << "another string"
=> [1, "Bob", 4.33, "another string"]

irb(main):026:0> my_array
my_array
=> [1, "Bob", 4.33, "another string"]

#+END_SRC

*Note:* Both the *push* and *<<* methods mutate the caller.

*** The *map* and *collect* methods
- Iterates over an array and applies a block to each element
- Returns a new array with the results
- *collect* is an alias to *map (they do the same thing)
- (These methods do not mutate the caller.)

  Here's an example of how to use *map* to square all of the numbers in an array:

#+BEGIN_SRC ruby
irb(main):029:0> a = [1, 2, 3, 4]
a = [1, 2, 3, 4]
=> [1, 2, 3, 4]

irb(main):030:0> a.map { |num| num**2 }
a.map { |num| num**2 }
=> [1, 4, 9, 16] 

irb(main):031:0> a.collect { |num| num**2 }
a.collect { |num| num**2 }
=> [1, 4, 9, 16]

irb(main):032:0> a
a
=> [1, 2, 3, 4]
#+END_SRC

*** The *delete_at* method
- Deletes the value at a specified index.
- Mutates the caller.

  #+BEGIN_SRC ruby
irb(main):032:0> a
a
=> [1, 2, 3, 4]

irb(main):033:0> a.delete_at(1)
a.delete_at(1)
=> 2

irb(main):034:0> a
a
=> [1, 3, 4]
  
  #+END_SRC

  
*** The *delete* method
- Deletes matching values when the index is unknown.
- This is a destructive method (it mutates the caller).

  #+BEGIN_SRC ruby
irb(main):001:0> my_books = ["Bubishi", "Business Kanji", "Chinese Radicals Vol. 2", "Aperture 3"]
my_books = ["Bubishi", "Business Kanji", "Chinese Radicals Vol. 2", "Aperture 3"]
=> ["Bubishi", "Business Kanji", "Chinese Radicals Vol. 2", "Aperture 3"]

irb(main):002:0> my_books
my_books
=> ["Bubishi", "Business Kanji", "Chinese Radicals Vol. 2", "Aperture 3"]

irb(main):003:0> my_books.delete("Aperture 3")
my_books.delete("Aperture 3")
=> "Aperture 3"

irb(main):004:0> my_books
my_books
=> ["Bubishi", "Business Kanji", "Chinese Radicals Vol. 2"]
  #+END_SRC

*** The *uniq* method
- Iterates through the array, deleting any duplicate values.
- It's non-destructive.
- You can add a *bang* (!) to the method to make it destructive, which make is work much like *delete* (this is just like JavaScript).

  #+BEGIN_SRC ruby
irb(main):001:0> b = [1, 1, 2, 2, 3, 3, 4, 4]
b = [1, 1, 2, 2, 3, 3, 4, 4]
=> [1, 1, 2, 2, 3, 3, 4, 4]

irb(main):002:0> b
b
=> [1, 1, 2, 2, 3, 3, 4, 4]

irb(main):003:0> b.uniq
b.uniq
=> [1, 2, 3, 4]

irb(main):004:0> b
b
=> [1, 1, 2, 2, 3, 3, 4, 4]  

  #+END_SRC

  By adding the *bang* operator (!), we can make *uniq* destructive:

  #+BEGIN_SRC ruby

irb(main):004:0> b
b
=> [1, 1, 2, 2, 3, 3, 4, 4]

irb(main):005:0> b.uniq!
b.uniq!
=> [1, 2, 3, 4]

irb(main):006:0> b
b
=> [1, 2, 3, 4]
  
  #+END_SRC

*Note:* *uniq* and *uniq!* are two distinct methods. You can't just append a *!* to any non-desructive method to make it function destructively.

** Iterating over an Array
In the Loops section, we looked at iterating with *each*. The Ruby standard library includes other similar methods. the *select* method is a good example.

*** The *select* method
The *select* method iterates over an array and returns a new array of elements that return a *true* value.

#+BEGIN_SRC ruby

irb(main):007:0> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

irb(main):008:0> numbers
numbers
=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

irb(main):009:0> numbers.select { |number| number > 4 }
numbers.select { |number| number > 4 }
=> [5, 6, 7, 8, 9, 10]

irb(main):010:0> numbers
numbers
=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

#+END_SRC

As expected, the values returned were all greater than 4. And we can see that this method is non-destructive.

*** Transformation
Make sure to confirm whether or not a method is destructive, either in the Ruby documentation or by testing in irb. Methods with a bang operator (!) at the end might be destructive (though not necessarily); some methods, like *pop* and *push* are destructive, but don't have the bang operator.

*** Mutating the Caller: The Sequel
It is extremely important to understand that some methods, when called, can forever change an argument. The authors gave some more examples in context.

Why does the first method mutate the caller, while the second does not?

*File:* [[07_arrays/mutate_test.rb]]
#+BEGIN_SRC ruby :tangle 07_arrays/mutate_test.rb
# 07_arrays/mutate_test.rb
# This program demonstrates how the *pop* method is destructive, while the *select* method is not.
    def mutate(arr)
      arr.pop
    end
  
    def not_mutate(arr)
      arr.select { |i| i >3 }
    end


a = [1, 2, 3, 4, 5, 6]
mutate(a)
not_mutate(a)

puts a
#+END_SRC

*Output:*

#+BEGIN_SRC sh
小A曰:ruby mutate_test.rb 
1
2
3
4
5
#+END_SRC

As we've seen before, the *pop* method is destructive, while the *select* method is not.

Because this program calls the *pop method first, the final '6' is lost. When *select* is called, it does not modify the remaining elements.

*** Nested Arrays
Arrays can be nested within each others. Look at this example of a list of sand volleyball tournament players:

#+BEGIN_SRC ruby

irb(main):013:0> teams = [['Joe', 'Steve'], ['Frank', 'Molly'], ['Dan', 'Sara']]
teams = [['Joe', 'Steve'], ['Frank', 'Molly'], ['Dan', 'Sara']]
=> [["Joe", "Steve"], ["Frank", "Molly"], ["Dan", "Sara"]]

irb(main):014:0> teams
teams
=> [["Joe", "Steve"], ["Frank", "Molly"], ["Dan", "Sara"]]

#+END_SRC

We can find teams by index:
#+BEGIN_SRC ruby

irb(main):015:0> teams[1]
teams[1]
=> ["Frank", "Molly"]

#+END_SRC

** Comparing Arrays
Use the *==* operator to compare equality.

In this example, arrays 'a' and 'b' are not equal. By using *pop* to remove the last number in the 'b' array, and *unshift* to add a number to the front, they become equal:

#+BEGIN_SRC ruby

irb(main):016:0> a = [1, 2, 3]
a = [1, 2, 3]
=> [1, 2, 3]

irb(main):017:0> b = [2, 3, 4]
b = [2, 3, 4]
=> [2, 3, 4]

irb(main):018:0> a == b
a == b
=> false

irb(main):019:0> b.pop
b.pop
=> 4

irb(main):020:0> b.unshift(1)
b.unshift(1)
=> [1, 2, 3]

irb(main):021:0> a == b
a == b
=> true

#+END_SRC

*** *to_s*
We've seen this method before (*gets.chomp.to_s*). When we use string interpolation, Ruby calls this method behind the scenes, to print the required string value to the screen.

#+BEGIN_SRC ruby

irb(main):022:0> a = ["falling off a log"]
a = ["falling off a log"]
=> ["falling off a log"]

irb(main):023:0> "It's as easy as #{a}"
"It's as easy as #{a}"
=> "It's as easy as [\"falling off a log\"]"

irb(main):024:0> b = [1, 2, 3]
b = [1, 2, 3]
=> [1, 2, 3]

irb(main):025:0> "It's as simple as #{b}"
"It's as simple as #{b}"
=> "It's as simple as [1, 2, 3]"

#+END_SRC

** Common Array Methods
Here are some common array methods in Ruby. 
See the Ruby [[http://www.ruby-doc.org/core-2.1.3/Array.html][Array Class]] documentation for more examples...

*** *include?*
This method checks to see if the given argument is included in the array. (The use of '?' generally indicates that a boolean value will be returned. This is a convention, and not a property of the language, just like using the bang operator to mutate the caller).

#+BEGIN_SRC ruby

irb(main):027:0> a = [1, 2, 3, 4, 5]
a = [1, 2, 3, 4, 5]
=> [1, 2, 3, 4, 5]

irb(main):028:0> a.include?(3)
a.include?(3)
=> true

irb(main):029:0> a.include?(6)
a.include?(6)
=> false
#+END_SRC

*** flatten
According to the authors, "The flatten method can be used to take an array that contains nested arrays and create a one-dimensional array" ([[http://www.gotealeaf.com/books/ruby/read/arrays#flatten][Source]]).

#+BEGIN_SRC ruby

irb(main):030:0> a = [1, 2, [3, 4, 5], [6, 7]]
a = [1, 2, [3, 4, 5], [6, 7]]
=> [1, 2, [3, 4, 5], [6, 7]]

irb(main):031:0> a
a
=> [1, 2, [3, 4, 5], [6, 7]]

irb(main):032:0> a.flatten
a.flatten
=> [1, 2, 3, 4, 5, 6, 7]

#+END_SRC

*** *each_index*
"The each_index method iterates through the array much like the each method, however the variable represents the index number as opposed to the value at each index. It passes the index of the element into the block and you may do as you please with it. The original array is returned" ([[http://www.gotealeaf.com/books/ruby/read/arrays#each_index][Source]]).

#+BEGIN_SRC ruby
irb(main):033:0> a = [1, 2, 3, 4, 5]
a = [1, 2, 3, 4, 5]
=> [1, 2, 3, 4, 5]
irb(main):034:0> a.each_index { |i| puts "This is index #{i}" }
a.each_index { |i| puts "This is index #{i}" }
This is index 0
This is index 1
This is index 2
This is index 3
This is index 4
=> [1, 2, 3, 4, 5]

#+END_SRC

As we've seen before, the index starts with 0, so if we wanted to start with the number one, could add '+1' to the variable:

#+BEGIN_SRC ruby
irb(main):035:0> a.each_index { |i| puts "This is index #{i+1}" }
a.each_index { |i| puts "This is index #{i+1}" }
This is index 1
This is index 2
This is index 3
This is index 4
This is index 5
=> [1, 2, 3, 4, 5]
#+END_SRC

*** *each_with_index*
Similar to *each_index*, but it allows us to manipulate both the value and the index:

#+BEGIN_SRC ruby
irb(main):036:0> a = [1, 2, 3, 4, 5]
a = [1, 2, 3, 4, 5]
=> [1, 2, 3, 4, 5]

irb(main):037:0> a.each_with_index { |val, idx| puts "#{idx+1}. #{val}" }
a.each_with_index { |val, idx| puts "#{idx+1}. #{val}" }
1. 1
2. 2
3. 3
4. 4
5. 5
=> [1, 2, 3, 4, 5]

#+END_SRC

*** *sort*
This method returns a sorted array.

#+BEGIN_SRC ruby
irb(main):039:0> a = [5, 3, 8, 2, 4, 1]
a = [5, 3, 8, 2, 4, 1]
=> [5, 3, 8, 2, 4, 1]

irb(main):040:0> a.sort
a.sort
=> [1, 2, 3, 4, 5, 8]
#+END_SRC

This method is non-destructive. Remember to always confirm this in irb and/or in the documentation.

*** *product*
The *product* method combines methods in different ways, returning an array that combines elements from all of the arrays.

#+BEGIN_SRC ruby
irb(main):041:0> [1, 2, 3].product([4, 5])
[1, 2, 3].product([4, 5])
=> [[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]
#+END_SRC

** *each* vs. *map*

*** each
"*each* provides a simple way of iterating over a collection in Ruby and is more preferred to using the *for* loop. The *each* method works on objects that allow for iteration and is commonly used along with a block. If given a block, *each* runs the code in the block once for each element in the collection and returns the collection it was invoked on. If no block is given, it returns an [[http://www.ruby-doc.org/core-2.1.3/Enumerator.html][Enumerator]]" ([[http://www.gotealeaf.com/books/ruby/read/arrays#eachvsmap][Source]]).

#+BEGIN_SRC ruby

irb(main):042:0> a = [1, 2, 3]
a = [1, 2, 3]
=> [1, 2, 3]

irb(main):043:0> a.each { |e| puts e }
a.each { |e| puts e }
1
2
3
=> [1, 2, 3]

#+END_SRC
That is the most common way to use *each*.

We could also modify the elements and print them out:

#+BEGIN_SRC ruby
irb(main):044:0> a = [1, 2, 3]
a = [1, 2, 3]
=> [1, 2, 3]

irb(main):045:0> a.each { |e| puts e + 2 }
a.each { |e| puts e + 2 }
3
4
5
=> [1, 2, 3]
#+END_SRC

In this example, only an Enumerator is returned (no block):

#+BEGIN_SRC ruby
irb(main):046:0> a = [1, 2, 3]
a = [1, 2, 3]
=> [1, 2, 3]

irb(main):047:0> a.each
a.each
=> #<Enumerator: [1, 2, 3]:each>
#+END_SRC

*** *map*
From the text:

"*map* also works on objects that allow for iteration. Like *each*, when given a block it invokes the given block once for each element in the collection. Where it really differs from *each* is the returned value. *map* creates and returns a new array containing the values returned by the block" ([[http://www.gotealeaf.com/books/ruby/read/arrays#eachvsmap][Source]]).

#+BEGIN_SRC ruby
irb(main):049:0> a.map { |x| X**2 }
a.map { |x| X**2 }
NameError: uninitialized constant X
	from (irb):49:in `block in irb_binding'
	from (irb):49:in `map'
	from (irb):49
	from /usr/bin/irb:12:in `<main>'

irb(main):050:0> a.map { |x| x**2 }
a.map { |x| x**2 }
=> [1, 4, 9]

#+END_SRC

I accidentally typed a capital 'X', which caused irb to throw an error. It's important to watch for small typing mistakes, because they can cause big headaches, sometimes.

Each element was squared, and sent to a new array. Here's another example that clearly shows how *map* creates a new array with the returned value of the block:

#+BEGIN_SRC ruby
irb(main):051:0> a = [ 1, 2, 3]
a = [ 1, 2, 3]
=> [1, 2, 3]

irb(main):052:0> a.map { |x| puts x**2 }
a.map { |x| puts x**2 }
1
4
9
=> [nil, nil, nil]
#+END_SRC

Every time the block is invoked, *nil* is returned, so all of the elements in the new array are *nil*.

If no block is given, *map* returns an *Enumerator*:

#+BEGIN_SRC rub
irb(main):055:0> a = [1, 2, 3]
a = [1, 2, 3]
=> [1, 2, 3]

irb(main):056:0> a.map
a.map
=> #<Enumerator: [1, 2, 3]:map>

#+END_SRC

According to the authors, but *each* and *map are important methods, but they can be confusing. They explain that we can remember the difference this way:

- Use *each* for iteration
- use *map* for transformation

** *Array Methods Covered in this Section*

| Method          | Example Syntax            | Description                                                                                                                        | Destructive? | Comments                                                                                                       |
|-----------------+---------------------------+------------------------------------------------------------------------------------------------------------------------------------+--------------+----------------------------------------------------------------------------------------------------------------|
| first           | array.first               | prints first element/array                                                                                                         | no           | with an argument, you can select more than just the first element (e.g., string.push(2) prints the first two.) |
| last            | array.last                | prints last element/array                                                                                                          | no           | with an argument, you can select more than just the last element (e.g., string.push(2) prints the last two.)   |
| pop             | array.pop                 | prints the last element                                                                                                            | yes          | with an argument, you can pop more than jsut the last element (e.g., string.pop(2) pops the last two.)         |
| shovel (<<)     | array << X                | adds item to end of array                                                                                                          | yes          | same as *push*                                                                                                 |
| push            | array.push                | adds item to end of array                                                                                                          | yes          | same as *<<*                                                                                                   |
| map             | array.map                 | iterates over an array and applies a block to each element/new array                                                               | no           | same as *collect*                                                                                              |
| collect         | array.collect             | iterates over an array and applies a block to each element/new array                                                               | no           | same as *map*                                                                                                  |
| delete          | array.delete              | deletes matching values when the index is unknown                                                                                  | yes          |                                                                                                                |
| delete_at       | array.delete_at(arg)      | deletes the value at a specified index                                                                                             | yes          |                                                                                                                |
| uniq            | array.uniq                | iterates through the array, deleting any duplicate values                                                                          | no           |                                                                                                                |
| uniq!           | array.uniq!               | iterates through the array, deleting any duplicate values                                                                          | yes          | this is not considered a different method from *uniq*                                                          |
| select          | array.select { }          | iterates over an array, returning a new array of 'true' elements                                                                   | no           |                                                                                                                |
| to_s            | gets.chomp.to_s           | captures up to end of string, and cuts off whitespace/newline                                                                      | yes          | when we use string interpolation ( #{foo} ), Ruby calls *to_s* behind the scenes.                              |
| include?        | array.include?(3)         | checks to see if the given arguemnt is included in the array                                                                       | no           | boolean (T/F) value                                                                                            |
| flatten         | array.flatten             | takes a nested array and puts all elements in a one-dimensional array                                                              | no           |                                                                                                                |
| each            | array.each                | iterates over array, runs the code in block                                                                                        | no           | if no block is given it returns an Enumerator                                                                  |
| each_index      | array.each_index          | like the *each* method, but the variable represents the index number, rather than the value at each index; passes index into block | no           |                                                                                                                |
| each_with_index | array.each_with_index{ }  | similar to *each_index*, but it allows us to manipulate both the value and the index                                               | no           |                                                                                                                |
| sort            | array.sort                | returns a sorted array                                                                                                             | no           |                                                                                                                |
| product         | array.product([foo, bar]) | combines nested arrays in all possible combinations                                                                                | no           |                                                                                                                |

** Exercises
  :PROPERTIES:
  :ARCHIVE_TIME: 2014-10-20 Mon 20:37
  :ARCHIVE_FILE: ~/tealeaf/pre-course1/learn_ruby/notes.org
  :ARCHIVE_OLPATH: Arrays
  :ARCHIVE_CATEGORY: notes
  :END:

*** Problem 1
Below we have given you an array and a number. Write a program that checks to see if the number appears in the array.


#+BEGIN_SRC ruby 

arr = [1, 3, 5, 7, 9, 11]
number = 3

#+END_SRC

*** Solution 1

*File:* [[07_arrays/include_3.rb]]
#+BEGIN_SRC ruby :tangle 07_arrays/include_3.rb
# 07_arrays/include_3.rb

arr = [1, 3, 5, 7, 9, 11]

x = arr.include?(3)
puts x

#+END_SRC

In irb:
#+BEGIN_SRC ruby

irb(main):057:0> arr = [1, 3, 5, 7, 9, 11]
arr = [1, 3, 5, 7, 9, 11]
=> [1, 3, 5, 7, 9, 11]

irb(main):058:0> arr.include?(3)
arr.include?(3)
=> true

#+END_SRC

The authors provided two solutions:
#+BEGIN_SRC ruby
arr.each do |num|
  if num == number
    puts "#{number} is in the array."
  end
end

# ... or...
if arr.include?(number)
  puts "#{number} is indeed in the array."
end
#+END_SRC

My version is obviously too simple. It only provides a boolean (true/false) answer to whether the array contains a '3'.

Let's try this with a modified version, just for practice.

*File:* [[07_arrays/include_3_corrected.rb]]
#+BEGIN_SRC ruby :tangle 07_arrays/include_3_corrected.rb
        # 07_arrays/include_3_corrected.rb
        arr = [1, 3, 5, 7, 9, 11]
        number = 11
        
        arr.each do |num|
          if num == number
            puts "#{number} is in the array."
          end
        end
        
        # ... or ...
  if arr.include?(number)
    puts "#{number} is included in the array."
  end
  
#+END_SRC

And here's the output:

#+BEGIN_SRC sh

小A曰:ruby include_3_corrected.rb
11 is in the array.
11 is included in the array.

#+END_SRC
*Extra Credit*

This isn't really the answer that the authors were looking for, but the first example could be modified to obtain user input for a number to search. Here's how I'd change that:

*File:* 07_arrays/include_3_improved.rb
#+BEGIN_SRC ruby :tangle 07_arrays/include_3_improved.rb
  # 07_arrays/include_3_improved.rb
  # Prompts the user for a number, and searches the array for the number.
  
  puts "Pick a number between 1 and 20"
  number = gets.chomp.to_i
  
  arr = [1, 3, 5, 7, 9, 11]
  arr.each do |num|
    if num == number
    puts "#{number} is in the array"
    end
  end
  
#+END_SRC

Here's the output:
#+BEGIN_SRC sh
小A曰:ruby include_3_improved.rb
Pick a number between 1 and 20
3
3 is in the array

小A曰:ruby include_3_improved.rb
Pick a number between 1 and 20
19
小A曰:

#+END_SRC

The problem with my code is that it only tells the user if the answer was correct. If an an 'else' statement, it will print out each failing iteration message. To improved this, I'd want to either find a way to print out, only once, that the number was not included, or else do some other kind of action.

It was worth taking a few minutes to try this, though, because I'm starting to see some connections, as well as advantages and disadvantages to different coding approaches...

*** Problem 2
What will the following programs return? What is value of arr after each?

#+BEGIN_SRC ruby
  #1.
  arr = ["b", "a"]
  arr = arr.product(Array(1..3))
  arr.first.delete(arr.first.last)
  
  #2.
  arr = ["b", "a"]
  arr = arr.product([Array(1..3)])
  arr.first.delete(arr.first.last)
  
#+END_SRC

*** Solution 2
1. My guess: RETURN: nil; arr=[["b", 2], ["b", 3], ["a", 1] 
   - First, the *product* method will combine the elements:
     arr = [["b", 1], ["b", 2], ["b", 3], ["a", 1], ["a", 2], ["a", 3]]
   - Then, the *first.delete* chained methods will delete the first and last items, so the final result will be: [["b", 2], ["b", 3], ["a", 1]
2. My guess: It will be the same as #1.
   
Two things that confuse me, though...

   First, the arguments for the *producet* method are different. In the first one, it looks like a regular argument, but in the second one, it's an array. I'm not sure if that matters. I have checked on www.ruby-doc.org, but the documentation for the *product* method doesn't seem to deal with this difference.

   Also, I'm not sure what this will return. In the documentation at http://www.ruby-doc.org/core-2.1.3/Array.html#method-i-product, it says:

   *"If given a block, product will yield all combinations and return self instead."*

   Now, keep in mind, I haven't done any testing or checked the answers. These are my guesses. Let's find out...

   *Solution*

   I was wrong. This makes a lot more sense to me, after watching the video walkthrough and trying this out in irb.

   I did check the documentation, but I made a couple mistakes when I looked at this:

   1. I assumed it would return 'nil' because I've been using 'puts...' so much, and that operation will return nil.
   2. I thought '.first.last' referred to the whole array, but it was only one element. That's why in my answer, I thought the first and last arrays would be deleted. Here's the answer for 1:

*Solution 1 Returns 1; arr = => [["b"], ["b", 2], ["b", 3], ["a", 1], ["a", 2], ["a", 3]]*

     Here's my work in irb:

     #+BEGIN_SRC ruby

irb(main):068:0> arr = ["b", "a"]
arr = ["b", "a"]
=> ["b", "a"]

irb(main):069:0> arr = arr.product(Array(1..3))
arr = arr.product(Array(1..3))
=> [["b", 1], ["b", 2], ["b", 3], ["a", 1], ["a", 2], ["a", 3]]

irb(main):070:0> arr.first.delete(arr.first.last)
arr.first.delete(arr.first.last)
=> 1

irb(main):071:0> arr
arr
=> [["b"], ["b", 2], ["b", 3], ["a", 1], ["a", 2], ["a", 3]]
     
      #+END_SRC

   *Solution 2: RETURNS: [1, 2, 3]; arr = => [["b"], ["a," [1, 2, 3]]]*

   I was wrong here, as well. The intersting difference here is that the nested arrays are not pairs, as above, but a 'b' or 'a' and then a three-numbered range of elements.

   #+BEGIN_SRC ruby

irb(main):073:0> arr = arr.product([Array(1..3)])
arr = arr.product(A[rray(1..3)])
=> [["b", [1, 2, 3]], ["a", [1, 2, 3]]]

irb(main):074:0> arr.first.delete(arr.first.last)
arr.first.delete(arr.first.last)
=> [1, 2, 3]

irb(main):075:0> arr
arr
=> [["b"], ["a", [1, 2, 3]]]
   
   #+END_SRC

   After playing with this in irb a little, and also watching the video walkthrough, I can see that my guess was wrong, but that's ok, because i don't have to guess. I can always check irb, doumentation, or other sources for more help and examples.

   Today, I had a lot of family committments, so I didn't get to spend as much time working on Ruby as I had planned. I think I can understand this exercise, but I'm going to spend some extra time tomorrow, working through a few more extra examples, just to make sure.

*** Lessons Learned from Exercise Two
I went through the video walkthrough again, and did some practice in irb. These problems make more sense to me now. And I've come up with a few basic reminders for myself:
- When in doubt, break it into parts and check in irb.
- With a nested array/expression, start from the inner part and work your way outward.
- Ruby is an object-oriented language, with methods that can be stacked. Some Ruby code can become complicated, but when broken down, it makes sense!

*** Problem 3
How do you print the word "example" from the following array?
#+BEGIN_SRC ruby
arr = [["test", "hello", "world"],["example", "mem"]]
#+END_SRC

*** Solution 3
This is a question to see if we were paying attention in the last exercise, and to remind us, once again, to test in irb. :)

At first, I was thinking I could flatten the array, and then use the index(3) to print it. The only problem is, that didn't work. But then, while I was playing around, I looked at what I'd done in the last exercise, using 'first' and 'last' methods to isolate arrays and elements.

I tried this in irb, and it worked:




#+BEGIN_SRC ruby

irb(main):082:0> arr = [["test", "hello", "world"],["example", "mem"]]
arr = [["test", "hello", "world"],["example", "mem"]]
=> [["test", "hello", "world"], ["example", "mem"]]

irb(main):083:0> arr.last
arr.last
=> ["example", "mem"]

irb(main):084:0> arr.last.first
arr.last.first
=> "example"

#+END_SRC

This confused me, until I looked at the last answer. I checked the book's solution, and it was the same, though it also gave the following answer as an alternative:

#+BEGIN_SRC ruby
irb(main):092:0> arr = [["test", "hello", "world"], ["example", "mem"]]
arr = [["test", "hello", "world"], ["example", "mem"]]
=> [["test", "hello", "world"], ["example", "mem"]]

irb(main):093:0> arr[1][0]
arr[1][0]
=> "example"
#+END_SRC

*** Problem 4
What does each method return in the following example?
#+BEGIN_SRC ruby
arr = [15, 7, 18, 5, 12, 8, 5, 1]

1. arr.index(5)

2. arr.index[5]

3. arr[5]

#+END_SRC

Before I do anything in irb, here are my guesses:

1. arr.index(5) = 3
2. arr.index[5] = error
3. arr[5]       = error

Let's try them in irb:


#+BEGIN_SRC ruby

irb(main):094:0> arr = [15, 7, 18, 5, 12, 8, 5, 1]
arr = [15, 7, 18, 5, 12, 8, 5, 1]
=> [15, 7, 18, 5, 12, 8, 5, 1]

#1
irb(main):095:0> arr.index(5)
arr.index(5)
=> 3

#2
arr.index[5]
NoMethodError: undefined method `[]' for #<Enumerator: [15, 7, 18, 5, 12, 8, 5, 1]:index>
	from (irb):96
	from /usr/bin/irb:12:in `<main>'

#3
irb(main):099:0> arr[5]
arr[5]
=> 8
#+END_SRC

*Comments:*
1. This gave the first index position of the argument, as expected.
2. NoMethodError, from an undefined method. The *index* method needs an argument in parentheses (), but in this case, it was using the syntax for arrays, []. 
3. I was wrong. I thought this would be an error. Actually, this is the way to find the item at the index position within brackets. '8' is the fifth item in the array.

*** Problem 5
What is the value of a, b, and c in the following program?
#+BEGIN_SRC ruby

string = "Welcome to Tealeaf Academy!"
a = string[6]
b = string[11]
c = string[19]

#+END_SRC

*My Guess:*

OK, I think I know the answer. I think each of those arguments will be the letter in the string. But rather than wildly guess, I'm going to give myself a big clue:

#+BEGIN_SRC ruby
irb(main):100:0> string = "Welcome to Tealeaf Academy!"
string = "Welcome to Tealeaf Academy!"
=> "Welcome to Tealeaf Academy!"

irb(main):101:0> string.length
string.length
=> 27

irb(main):102:0> string[0]
string[0]
=> "W"

#+END_SRC

Yes! It looks like I was right! So here goes:
- a: 'e'
- b: 'T'
- c: 'A'

And the answer....*I was right!*

*** Problem 6
You run the following code...

#+BEGIN_SRC ruby
names = ['bob', 'joe', 'susan', 'margaret']
names['margaret'] = 'jody'

#+END_SRC

...and get the following error message:

#+BEGIN_SRC ruby
TypeError: no implicit conversion of String into Integer
  from (irb):2:in `[]='
  from (irb):2
  from /Users/username/.rvm/rubies/ruby-2.0.0-p353/bin/irb:12:in `<main>'

#+END_SRC

*** Solution 6

Here is my guess. Keeping in mind that I haven't actually seen the answer or tested in irb, I think I know what is happening here. It looks like the user is attempting to change the string 'margaret' to be 'jody,' but instead of using the index number to change it, the user has put in the string value. The error says "no implicit conversion of String into Integer," which means it was expecting an integer argument.

I predict that the following change will work:

#+BEGIN_SRC ruby
names = ['bob', 'joe', 'susan', 'margaret']
names[3] = 'jody'

#+END_SRC

And now to test in irb...

#+BEGIN_SRC ruby

irb(main):103:0> names = ['bob', 'joe', 'susan', 'margaret']
names = ['bob', 'joe', 'susan', 'margaret']
=> ["bob", "joe", "susan", "margaret"]

irb(main):104:0> names[3] = 'jody'
names[3] = 'jody'
=> "jody"

irb(main):105:0> names
names
=> ["bob", "joe", "susan", "jody"]

#+END_SRC

It looks like it worked!

*** Problem 7
Write a program that iterates over an array and builds a new array that is the result of incrementing each value in the original array by a value of 2. You should have two arrays at the end of this program, The original array and the new array you've created. Print both arrays to the screen using the *p* method instead of *puts*.

*** Solution 7
#+BEGIN_SRC ruby :tangle 07_arrays/solution_7.rb
    #07_arrays/solution_7.rb
    # increments array by two, and prints both with "p" method
    
    hachi = [1, 2, 3, 4, 5, 6, 7, 8]
    
    hachi2 = hachi.map { |num| num+2 }
  
  
  p hachi
  p hachi2
#+END_SRC

#+BEGIN_SRC sh
小A曰:ruby solution_7.rb 
[1, 2, 3, 4, 5, 6, 7, 8]
[3, 4, 5, 6, 7, 8, 9, 10]

#+END_SRC

*Author's Solution*

#+BEGIN_SRC ruby
  arr = [1, 2, 3, 4, 5]
  new_arr = []
  
  arr.each do |n|
    new_arr << n + 2
  end
  
  p arr
  p new_arr
  
#+END_SRC

*Comments*

I spent some time trying to use the each method, but then thought it would be easier to use *map*. I didn't come up with anything this elegant. This one creates two methods, 'arr' and 'new_arr.' The former has the original values; the latter is empty. It assigns a value, 'n' to each element in the 'arr' array, and then adds two, uses the *<<* method to add to the new array. Then it prints out both arrays. Very cool!

I'd like try this:

*File:* [[07_arrays/solution7_corrected.rb]]
#+BEGIN_SRC ruby :tangle 07_arrays/solution7_corrected.rb
    
    hachi = [1, 2, 3, 4, 5, 6, 7, 8]
    hachi2 = []
  
    hachi.each do |num|
      hachi2 << num + 2
    end
  
  p hachi
  p hachi2
#+END_SRC

* Hashes
[[http://ruby-doc.org/core-2.1.3/Hash.html][Ruby 2.1.3 Hash Documentation]]

** What is a Hash?
- a data structure that stores items with keys
- unlike arrays, which store data in ordered lists, hashes use key-value pairs
- associative representation of data
- symbole = keys; data types = values
- surrounded by { } (curly braces) and separated by commas.
- With Ruby 1.9, the syntas changed (see below for examples)
  + Before 1.9: *{:name => 'Andrew'}*
  + 1.9 and later: *{name: 'Andrew'}*
    
** Syntax
Two main forms:
Old (Pre-Ruby 1.9 version): used => to separate key and value
#+BEGIN_SRC ruby
irb :001 > old_syntax_hash = {:name => 'bob'}
=> {:name=>'bob'}
#+END_SRC

New (Ruby 1.9 and later):

#+BEGIN_SRC ruby
irb :002 > new_hash = {name: 'bob'}
=> {:name=>'bob'}
#+END_SRC

Hashes can also contain multpile key-value pairs:

#+BEGIN_SRC ruby
irb(main):001:0> person = {height: '6 ft', weight: '160 lbs' }
person = {height: '6 ft', weight: '160 lbs' }
=> {:height=>"6 ft", :weight=>"160 lbs"}

#+END_SRC

You can add to an existing hash:

#+BEGIN_SRC ruby
irb(main):002:0> person[:hair] = 'brown'
person[:hair] = 'brown'
=> "brown"

irb(main):003:0> person[:age] = 62
person[:age] = 62
=> 62

irb(main):004:0> person
person
=> {:height=>"6 ft", :weight=>"160 lbs", :hair=>"brown", :age=>62}

#+END_SRC

You can also remove items:

#+BEGIN_SRC ruby
irb(main):005:0> person.delete(:age)
person.delete(:age)
=> 62

irb(main):006:0> person
person
=> {:height=>"6 ft", :weight=>"160 lbs", :hair=>"brown"}
#+END_SRC

Here's how to retrieve data from a hash:
#+BEGIN_SRC ruby
irb(main):007:0> person[:weight]
person[:weight]
=> "160 lbs"
#+END_SRC

You can also merge hashes together:
#+BEGIN_SRC ruby
irb(main):008:0> new_hash = {favorite_language: "Ruby"}
new_hash = {favorite_language: "Ruby"}
=> {:favorite_language=>"Ruby"}

irb(main):009:0> person.merge!(new_hash)
person.merge!(new_hash)
=> {:height=>"6 ft", :weight=>"160 lbs", :hair=>"brown", :favorite_language=>"Ruby"}

#+END_SRC

*Note:* using the (!) bang operator made this method destructive. The *merge* method is not destructive.

** Iterating over Hashes
Iterating over hashes is similar to iterating over arrays.

*File:* [[08_hashes/iterating_over_hashes.rb]]
#+BEGIN_SRC ruby :tangle 08_hashes/iterating_over_hashes.rb
  # 08_hashes/iterating_over_hashes.rb
  
  person = {name: 'bob', height: '6 ft', weight: '160 lbs', hair: 'brown' }
  
  person.each do |key, value|
    puts "Bob's #{key} is #{value}"
  end
  
#+END_SRC

*Output:*
#+BEGIN_SRC sh
小A曰:ruby iterating_over_hashes.rb 
Bob's name is bob
Bob's height is 6 ft
Bob's weight is 160 lbs
Bob's hair is brown
#+END_SRC

** Hashes as Optional Parameters
Hashes can accept optional parameters when you are creating methods. This can provide a great deal of flexibility for a programmer.

Here's an example:

*Link:* [[08_hashes/optional_parameters.rb]]
#+BEGIN_SRC ruby :tangle 08_hashes/optional_parameters.rb
  # 08_hashes/optional_parameters.rb
  
  def greeting(name, options = {})
    if options.empty?
      puts "Hi, my name is #{name}"
      else
      puts "Hi, my name is #{name} and I'm #{options[:age]}" +
        " years old and I live in #{options[:city]}."
    end
  end

greeting("Bob")
greeting("Bob", {age: 62, city: "New York City"})
#+END_SRC

*Important note:* When a hash is the last argument, the { } curly braces are not required. Rails often follow this convention.

** Hashes vs. Arrays
From the authors:

When deciding whether to use a hash or an array, ask yourself a few questions:

- Does this data need to be associated with a specific label? If yes, use a hash. If the data doesn't have a natural label, then typically an array will work fine.

- Does order matter? If yes, then use an array. As of Ruby 1.9, hashes also maintain order, but usually ordered items are stored in an array.

- Do I need a "stack" or a "queue" structure? Arrays are good at mimicking simple "first-in-first-out" queues, or "last-in-first-out" stacks.

  ([[http://www.gotealeaf.com/books/ruby/read/hashes#hashesvsarrays][Source]])

** A Note on Hash Keys
In addition to using symbols as keys (which is the most common form), we can use other data types:

#+BEGIN_SRC ruby

irb(main):010:0> {"height" => "6 ft"} # string as key
{"height" => "6 ft"} # string as key
=> {"height"=>"6 ft"}

irb(main):012:0> {["height"] => "6 ft"} # array as key
{["height"] => "6 ft"} # array as key
=> {["height"]=>"6 ft"}

irb(main):013:0> {1 => "one"} # integer as key
{1 => "one"} # integer as key
=> {1=>"one"}

irb(main):014:0> {45.324 => "forty-five point three two four" # float as key}
{45.324 => "forty-five point three two four" # float as key}

irb(main):015:1> {{key: "key"} => "hash as key"} # hash as key
{{key: "key"} => "hash as key"} # hash as key

#+END_SRC

Note that we must use the old (pre-Ruby 1.8) syntax when using other forms, besides symbols, as keys.

** Common Hash Methods

*** *has_key?*
- allows you to verify whether a hash contains a specific key
- returns boolean value

  #+BEGIN_SRC ruby

irb(main):022:0>  name_and_age = { "Bob" => 42, "Steve" => 31, "Joe" => 19}
 name_and_age = { "Bob" => 42, "Steve" => 31, "Joe" => 19}
=> {"Bob"=>42, "Steve"=>31, "Joe"=>19}

irb(main):023:0> name_and_age.has_key?("Steve")
name_and_age.has_key?("Steve")
=> true

irb(main):024:0> name_and_age.has_key?("Larry")
name_and_age.has_key?("Larry")
=> false
  
  #+END_SRC

*** *select*
- allows you to pass a block
- returns key-value pairs that evaluate to true when run through the block

  #+BEGIN_SRC ruby
irb(main):025:0> name_and_age.select { |k,v| k == "Bob"}
name_and_age.select { |k,v| k == "Bob"}
=> {"Bob"=>42}

irb(main):026:0> name_and_age.select { |k,v| (k =="Bob") || (v == 19) }
name_and_age.select { |k,v| (k =="Bob") || (v == 19) }
=> {"Bob"=>42, "Joe"=>19}
  
  #+END_SRC

*** *fetch* 
- when you pass a given key, it will return the value for that key (if it exists)
- you can specify an option to return if the value is empty
- Ruby Documentation: [[http://ruby-doc.org/core-2.1.3/Hash.html#method-i-fetch][Fetch Method]]
  
  #+BEGIN_SRC ruby
irb(main):027:0> name_and_age.fetch("Steve")
name_and_age.fetch("Steve")
=> 31

irb(main):028:0> name_and_age.fetch("Larry")
name_and_age.fetch("Larry")
KeyError: key not found: "Larry"
	from (irb):28:in `fetch'
	from (irb):28
	from /usr/bin/irb:12:in `<main>'

irb(main):029:0> name_and_age.fetch("Larry", "Larry isn't in this hash")
name_and_age.fetch("Larry", "Larry isn't in this hash")
=> "Larry isn't in this hash"

  #+END_SRC

*** *to_a*
- returns an array version of the hash
- non-destructive

  #+BEGIN_SRC ruby
irb(main):030:0> name_and_age.to_a
name_and_age.to_a
=> [["Bob", 42], ["Steve", 31], ["Joe", 19]]

irb(main):031:0> name_and_age
name_and_age
=> {"Bob"=>42, "Steve"=>31, "Joe"=>19}
  
  #+END_SRC

*** *keys and values*
It's easy to retrieve all of the keys or values from a hash.

#+BEGIN_SRC ruby

irb(main):033:0> name_and_age.keys
name_and_age.keys
=> ["Bob", "Steve", "Joe"]

irb(main):034:0> name_and_age.values
name_and_age.values
=> [42, 31, 19]

#+END_SRC

Because the keys and values are returned in an array, you can do other things, like print all of the keys in a hash:

#+BEGIN_SRC ruby
irb(main):035:0> name_and_age.keys.each { |k| puts k }

# return keys
name_and_age.keys.each { |k| puts k }
Bob
Steve
Joe
=> ["Bob", "Steve", "Joe"]

# return values
irb(main):036:0> name_and_age.values.each { |v| puts v }
name_and_age.values.each { |v| puts v }
42
31
19
=> [42, 31, 19]
#+END_SRC

** A Note on Hash Order
Before Ruby 1.9, hashes did not maintain order (unlike arrays). From 1.9 on, hashes can maintain the order that they're stored. It's important to remember this limitation with hashes when working with older versions of Ruby.

** Exercises

*** Problem 1
Given a hash of family members, with keys as the title and an array of names as the values, use Ruby's built-in [[http://www.ruby-doc.org/core-2.1.3/Hash.html#method-i-select][select method]] to gather only immediate family members' names into a new array.

#+BEGIN_SRC ruby
# Given

family = {  uncles: ["bob", "joe", "steve"],
            sisters: ["jane", "jill", "beth"],
            brothers: ["frank","rob","david"],
            aunts: ["mary","sally","susan"]
          }

#+END_SRC

*** Solution 1
I only want to get teh values for sistes and brothers. I also know that the *select* method will return a new hash of 'true' values.

Here's my solution in irb:
#+BEGIN_SRC ruby
irb(main):026:0> family.select { |k,v| (k == :sisters) || (k == :brothers)}
=> {:sisters=>["jane", "jill", "beth"], :brothers=>["frank", "rob", "david"]}

#+END_SRC

I could also use the *to_a* method:

#+BEGIN_SRC ruby
irb(main):027:0> siblings = family.select { |k,v| (k == :sisters) || (k == :brothers)}
=> {:sisters=>["jane", "jill", "beth"], :brothers=>["frank", "rob", "david"]}

irb(main):028:0> siblings.to_a
=> [[:sisters, ["jane", "jill", "beth"]], [:brothers, ["frank", "rob", "david"]]]

#+END_SRC

Here's the authors' solution:
#+BEGIN_SRC ruby
irb(main):029:0> immediate_family = family.select do |k,v|
irb(main):030:1* k == :sisters || k == :brothers
irb(main):031:1> end
=> {:sisters=>["jane", "jill", "beth"], :brothers=>["frank", "rob", "david"]}
irb(main):032:0> arr = immediate_family.values.flatten
=> ["jane", "jill", "beth", "frank", "rob", "david"]
irb(main):033:0> p arr
["jane", "jill", "beth", "frank", "rob", "david"]
=> ["jane", "jill", "beth", "frank", "rob", "david"]

#+END_SRC

I had the right idea, but my final output was not flattened in the same way. I was so happy that I figured out the first part, that I was careless, and didn't provide the final answer in a single, flattened array. Here is my corrected answer, exported as a Ruby file:

*File:* [[08_hashes/exercise1.rb]]
#+BEGIN_SRC ruby :tangle 08_hashes/exercise1.rb
  # 08_hashes/exercise1.rb
  # Returns an array of siblings
  
  # Given
  
  family = {  uncles: ["bob", "joe", "steve"],
              sisters: ["jane", "jill", "beth"],
              brothers: ["frank","rob","david"],
              aunts: ["mary","sally","susan"]
            }
  
  # Return an array of only brothers and sisters
  
  immediate_family = family.select do |k,v|
    k == :sisters || k = :brothers
  end
  
  siblings = immediate_family.values.flatten
  
  p siblings
#+END_SRC

*** Problem 2
Look at Ruby's [[http://www.ruby-doc.org/core-2.1.0/Hash.html#method-i-merge][merge method]]. Notice that it has two versions. What is the difference between *merge* and *merge!*? Write a program that uses both and illustrate the differences.

*** Solution 2
*merge*
- Basic Syntax: h1.merge(h2)
- adds the contents of *h2* to *h1*
- if there is a 'conflict' (identical keys with different values, it will overwrite the h1 values with h2 values)
- non-destructive

*merge!*
- Basic Syntax: h1.merge!(h2)
- adds the contents of *h2* to *h1*
- if there is a 'conflict' (identical keys with different values, it will overwrite the h1 values with h2 values)
- destructive
 
To experiment, I created two hashes: h1, and h2:

#+BEGIN_SRC ruby
irb(main):001:0> h1 = {"a" => 100, "b" => 200, "c" => 300}
h1 = {"a" => 100, "b" => 200, "c" => 300}
=> {"a"=>100, "b"=>200, "c"=>300}

irb(main):002:0> h2 = {"c" => 400, "d" => 500, "e" => ["blue", "red", "green"]}
h2 = {"c" => 400, "d" => 500, "e" => ["blue", "red", "green"]}
=> {"c"=>400, "d"=>500, "e"=>["blue", "red", "green"]}

irb(main):003:0> h1.merge(h2)
h1.merge(h2)
=> {"a"=>100, "b"=>200, "c"=>400, "d"=>500, "e"=>["blue", "red", "green"]}

irb(main):004:0> h1
h1
=> {"a"=>100, "b"=>200, "c"=>300}

irb(main):005:0> h1.merge!(h2)
h1.merge!(h2)
=> {"a"=>100, "b"=>200, "c"=>400, "d"=>500, "e"=>["blue", "red", "green"]}

irb(main):006:0> h1
h1
=> {"a"=>100, "b"=>200, "c"=>400, "d"=>500, "e"=>["blue", "red", "green"]}

#+END_SRC

A couple observations:
- The value for "c" in h2 did, indeed, overwrite the value for "c" in h1. However, as expected, after calling the *merge* method, h1 was not changed. When I ran *method!*, h1 was permanently changed.
- The value for "e" in h2 was an array. it was also added to h1, as expected.
- This isn't news, but irb is an amazing resources for experimentation and testing!

  Now, I'll write a simple program that duplicates this behavior.

  *File:* [[08_hashes/solution2.rb]]
  #+BEGIN_SRC ruby :tangle 08_hashes/solution2.rb
      # 08_hashes/solution2.rb
      # Uses the merge and merge! methods to add values from h2 to h1

h1 = h1 = {"a" => 100, "b" => 200, "c" => 300}
h2 = {"c" => 400, "d" => 500, "e" => ["blue", "red", "green"]}

mer = h1.merge(h2)


puts "The hash values of h1 are #{h1}.\n After calling the 'merge' method, the values of h1 are #{mer}.\n But don't worry, h1 is still #{h1}."

mer2 = h1.merge!(h2)

puts "\n"

puts "The hash values of h1 are still #{h1}.\n But after calling the 'merge!' method, the values of h1 are #{mer2}.\n Now, h1 has permanently changed to #{h1}."

  #+END_SRC

  And here is the output:

  #+BEGIN_SRC sh
小A曰:ruby solution2.rb 
The value of h1 is {"a"=>100, "b"=>200, "c"=>300}.
 After calling the 'merge' method, the value of h1 is {"a"=>100, "b"=>200, "c"=>400, "d"=>500, "e"=>["blue", "red", "green"]}.
 But don't worry, h1 is still {"a"=>100, "b"=>200, "c"=>300}.

The value of h1 is still {"a"=>100, "b"=>200, "c"=>400, "d"=>500, "e"=>["blue", "red", "green"]}.
 But after calling the 'merge!' method, the value of h1 is {"a"=>100, "b"=>200, "c"=>400, "d"=>500, "e"=>["blue", "red", "green"]}.
 Now, the value of h1 has permanently changed to {"a"=>100, "b"=>200, "c"=>400, "d"=>500, "e"=>["blue", "red", "green"]}.
  
  #+END_SRC

  Here's the author's solution:

  #+BEGIN_SRC ruby

cat = {name: "whiskers"}
weight = {weight: "10 lbs"}
puts cat.merge(weight)
puts cat                  # => {:name=>"whiskers"}
puts weight               # => {:weight=>"10 lbs"}
puts cat.merge!(weight)
puts cat                  # => {:name=>"whiskers", :weight=>"10 lbs"}
puts weight               # => {:weight=>"10 lbs"}
  
  #+END_SRC

*** Problem 3
Using some of Ruby's built-in [[http://ruby-doc.org/core-2.1.3/Hash.html#method-i-fetch][Hash methods]], write a program that loops through a hash and prints all of the keys. Then write a program that does the same thing except printing the values. Finally, write a program that prints both.

*** Solution 3

My first thought was that I could use *each*. Here's how that works:

#+BEGIN_SRC ruby
      irb(main):002:0> hash = {"a" => 100, "b" => 200, "c" => "Jon"}
        hash = {"a" => 100, "b" => 200, "c" => "Jon"}
        => {"a"=>100, "b"=>200, "c"=>"Jon"}
        
      irb(main):003:0> hash.each do |k,v|
        hash.each do |k,v|
        
      irb(main):004:1* puts k
        puts k
      
      irb(main):005:1> end
        end
        a
        b
        c
        => {"a"=>100, "b"=>200, "c"=>"Jon"}
        
#+END_SRC

But when I checked [[http://ruby-doc.org/core-2.1.3/Hash.html#method-i-each_key][the documentation]], I found three methods that are tailor-made for this exercise:

- *each_key*
- *each_pair*
- *each_value*

Let's use these to complete the exercise!

*File:* [[08_hashes/solution3.rb]]

#+BEGIN_SRC ruby :tangle 08_hashes/solution3.rb
# 08_hashes/solution3.rb

hash = {name: "John", age: 27, occupation: "developer"}

# Program 1: use the each_key method to find the keys in a hash

puts "Here is a list of the keys: "
hash.each_key { |key| puts "- #{key}" }
puts "\n"



# Program 2: use the each_value method to find the values in a hash

puts "Here is a list of the values: "
hash.each_value { |value| puts "+ #{value}" }
puts "\n"

# Pogram 3: use the each_pair method to find both the keys and values in a hash

puts "Here is a list of keys and their values:"
hash.each_pair {|key, value| puts "#{key} is #{value}."}
puts "\n"

puts "Is there anything else I can help help with?" 

#+END_SRC

And here is the output:

#+BEGIN_SRC sh
小A曰:ruby solution3.rb
Here is a list of the keys: 
- name
- age
- occupation

Here is a list of the values: 
+ John
+ 27
+ developer

Here is a list of keys and their values:
name is John.
age is 27.
occupation is developer.

Is there anything else I can help help with?

#+END_SRC

And here is the authors' solution: 
#+BEGIN_SRC ruby
opposites = {positive: "negative", up: "down", right: "left"}

opposites.each_key { |key| puts key }
opposites.each_value { |value| puts value }
opposites.each { |key, value| puts "The opposite of #{key} is #{value}" }

#+END_SRC

I'd say mine is good. Interestingly enough, they use *each* intead of *each_pair*, which was my first instinct.

*** Problem 4
Given the following expression, how would you access the name of the person?

#+BEGIN_SRC ruby
person = {name: 'Bob', occupation: 'web developer', hobbies: 'painting'}
#+END_SRC

*** Solution 4
I think the *fetch* method would be the easiest solution.

#+BEGIN_SRC ruby
irb(main):006:0> person = {name: 'Bob', occupation: 'web developer', hobbies: 'painting'}
=> {:name=>"Bob", :occupation=>"web developer", :hobbies=>"painting"}
irb(main):007:0> person.fetch(:name)
=> "Bob"

#+END_SRC

If I create that as a file:

*File:* [[08_hashes/solution4.rb]]
#+BEGIN_SRC ruby :tangle 08_hashes/solution4.rb

# 08_hashes/solution4.rb


# Fetches the name from the hash
person = {name: 'Bob', occupation: 'web developer', hobbies: 'painting'}

name = person.fetch(:name)
puts name

#+END_SRC

The authors proposed a simpler solution:
#+BEGIN_SRC ruby

person = {name: 'Bob', occupation: 'web developer', hobbies: 'painting'}

puts person[:name]

#+END_SRC

*** Problem 5
What method could you use to find out if a Hash contains a specific value in it? Write a program to demonstrate this use.

*** Solution 5

A few methods that could help find a specific value:
- *select*
- *fetch*
- *has_value?*

Here's a program that uses all three:

*File:* [[08_hashes/solution5.rb]]
#+BEGIN_SRC ruby :tangle 08_hashes/solution5.rb
    # 08_hashes/solution5.rb
    
    masterpieces = {title1: "War and Peace", author1: "Tolstoy", title2: "The Scarlet Letter", author2: "Hawthorne", title3: "Moby Dick", author3: "Melville" }
    
    # Using the has.value? method
    puts "Using the has.value? method:\n"
    v = masterpieces.has_value?("Melville")
    puts "True or false...Melville is one of the authors:\n"
    puts v
#+END_SRC

The authors offer a more elegant solution, using a conditional:
#+BEGIN_SRC ruby 
has_value?

if opposites.has_value?("negative")
  puts "Got it!"
else
  puts "Nope!"
end
#+END_SRC

I can use this approach to improve my answer:

*File:* [[08_hashes/solution5_improved.rb]]
#+BEGIN_SRC ruby :tangle 08_hashes/solution5_improved.rb
  # 08_hashes/solution5_improved.rb
  
  masterpieces = {title1: "War and Peace", author1: "Tolstoy", title2: "The Scarlet Letter", author2: "Hawthorne", title3: "Moby Dick", author3: "Melville" }
  
  # Using the has.value? method
  
  if masterpieces.has_value?("Melville")
    puts "Yep. Melville's in there!"
  else
    puts "Nope. Melville's not in there."
  end  


#+END_SRC

Review, review, review...

*** Problem 6
Given the array...

#+BEGIN_SRC ruby
words =  ['demo', 'none', 'tied', 'evil', 'dome', 'mode', 'live',
          'fowl', 'veil', 'wolf', 'diet', 'vile', 'edit', 'tide',
          'flow', 'neon']

#+END_SRC
Write a program that prints out groups of words that are anagrams. Anagrams are words that have the same exact letters in them but in a different order. Your output should look something like this:

#+BEGIN_SRC ruby
  ["demo", "dome", "mode"]
  ["neon", "none"]
  (etc)

#+END_SRC


*** Solution 6
I've struggled with this one. I thought I could accomplish this with regex, so I spent some time looking at the documentation, and I skipped to the next section of the book, to glance over that. I use regular expressions, but I'm not even in the same ballpark as [[http://shop.oreilly.com/product/9780596528126.do#tab_03_2][Jeffrey Friedl]], but I can string together some basic searches.

Unfortunately, I found some useful tools, like the *match* method, but it didn't work with Hashes (it's also not listed as a hash method). I also thought about using the select method. I think I could find /one/ anagram, but parsing a file, iterating the contents, and finding all of them, and grouping them into new arrays? I'm stumped. So I'm going to give up, and "cheat" and look at the solution from the book...

Here's the answer the authors have provided:

#+BEGIN_SRC ruby
result = {}

words.each do |word|
  key = word.split('').sort.join
  if result.has_key?(key)
    result[key].push(word)
  else
    result[key] = [word]
  end
end

result.each do |k, v|
  puts "------"
  p v
end
#+END_SRC

This is brilliant, and while I'm disappointed I couldn't come up with a working answer on my own, I'm excited to see a program like this, that solves a complex problem, elegantly! I have to keep working hard, so that I can come up with solutions like this on my own.

*File:* [[08_hashes/solution6.rb]]
#+BEGIN_SRC ruby :tangle 08_hashes/solution6.rb
          # 08_hashes/solution6.rb
      
      # Create sets of anagrams from the following words
  words =  ['demo', 'none', 'tied', 'evil', 'dome', 'mode', 'live',
            'fowl', 'veil', 'wolf', 'diet', 'vile', 'edit', 'tide',
            'flow', 'neon']    
  
  # Create an empty hash to store the answer
  result = {}
  
  words.each do |word|
    key = word.split('').sort.join
    if result.has_key?(key)
      result[key].push(word)
    else
      result[key] = [word]
    end
  end
  
  result.each do |k, v|
    puts "------"
    p v
  end
#+END_SRC

Here's the output:

#+BEGIN_SRC sh
小A曰:ruby solution6.rb 
------
["demo", "dome", "mode"]
------
["none", "neon"]
------
["tied", "diet", "edit", "tide"]
------
["evil", "live", "veil", "vile"]
------
["fowl", "wolf", "flow"]

#+END_SRC

As an experiment, I'd like to do an extra credit exercise to practice this idea. 

This program takes each word form the array, and puts them into a new list, grouped by words that share the last letter.

I had to spend some time playing around with methods to figure this, but I finally did! I added some words, so that the output would be grammtically correct, when it said, "The words end in (letter)". 

*File:* [[08_hashes/solution6_extra_credit.rb]]
#+BEGIN_SRC ruby :tangle 08_hashes/solution6_extra_credit.rb
        # 08_hashes/solution6_extra_credit.rb
        # This program takes each of the following words and groups them by last letter. (Each new array shares the last letter.)

        words =  ['demo', 'none', 'tied', 'evil', 'dome', 'mode', 'live',
                  'fowl', 'veil', 'wolf', 'diet', 'vile', 'edit', 'tide',
                  'flow', 'neon', 'taco', 'lead', 'self', 'grow', 'moon']
        
  
        
        
        result = {}
        
        words.each do |word|
           key = word.split(", ").join[3]
          if result.has_key?(key)
            result[key].push(word)
          else
            result[key] = [word]
          end
        end
        
        result.each do |k, v|
          puts "------\nThese words end in #{k}:"
          puts v.join(", ")
        end
      
#+END_SRC

Here's the output:
#+BEGIN_SRC sh

小A曰:ruby solution6_extra_credit.rb
------
These words end in o:
demo, taco
------
These words end in e:
none, dome, mode, live, vile, tide
------
These words end in d:
tied, lead
------
These words end in l:
evil, fowl, veil
------
These words end in f:
wolf, self
------
These words end in t:
diet, edit
------
These words end in w:
flow, grow
------
These words end in n:
neon, moon

#+END_SRC

*** Problem 7
Given the following code...

#+BEGIN_SRC ruby
x = "hi there"
my_hash = {x: "some value"}
my_hash2 = {x => "some value"}

#+END_SRC
What's the difference between the two hashes that were created?

*** Solution 7

*File:* [[08_hashes/solution7.md]]
#+BEGIN_SRC markdown :tangle 08_hashes/solution7.md

### My answers
1. my_hash uses the symbol ':x' (Ruby 1.9 or later)
2. my_hash2 uses the older, pre-1.9 'hash-rocket'.

### The authors' answer
The first hash that was created used a symbol x as the key. The second hash used the string value of the x variable as the key.

### My comments
In addition to 'hash rocket,' I should remember that **=>** is a 'string value of the x variable.'
#+END_SRC

*** Problem 8
If you see this error, what do you suspect is the most likely problem?

#+BEGIN_SRC ruby
NoMethodError: undefined method `keys' for Array
#+END_SRC
A. We're missing keys in an array variable.

B. There is no method called keys for Array objects.

C. keys is an Array object, but it hasn't been defined yet.

*** Solution 8

*File:*[[08_hashes/solution8.md]]
#+BEGIN_SRC markdown :tangle 08_hashes/solution8.md
Unfortunately, I've seen that error, more than once...The answer is definitely **B.**

I checked the authors' answer, and I was right. Here's hoping I never see that error again! :)
#+END_SRC


* Files 
- exist on durable storage
- can be shared or validated to other formats
  
In this chapter, we'll look at common formats:
- json
- csv
- xml/html
- xls
  
The [[http://www.ruby-doc.org/core-2.1.3/IO.html][IO Class Documentation]] for Ruby 2.1.3 documents the modes and options available for Ruby files.

** Creating a file 
We can create files from within irb. The files will be created in the directory where irb was opened.

#+BEGIN_SRC ruby
irb(main):001:0> my_file = File.new("simple_file.txt", "w+")
my_file = File.new("simple_file.txt", "w+")
=> #<File:simple_file.txt>
irb(main):002:0> my_file.close
my_file.close
=> nil
#+END_SRC

** Opening Files
We can open existing files with the *File.open* command, which takes various arguments, including:
- *r*: read-only (starts at beginning of file)
- *w*: write-only (if the file exists, overwrites everything in the file)
- *w+:* read and write (if the file exists, overwrites everything in the file)
- *a+:* read-write (if file exists, starts at end of file. Otherwise creates a new file). Suitable for updating files.
  
*** Open File For Reading
This is simple in Ruby. Here are a couple options:

- *File.read("file_name")* - Spits out entire contents of the file.
- *File.readlines("file_name")* - Reads the entire file based on individual lines and returns those lines in an array.
  
*** Open File For Writing
- The standard workflow is open-use-close.
- We can use *write* or *puts* to write files.
  + *puts* adds a line break to the end of strings
  + *write* does not
- Closing files is very important. Ruby will automatically close files if the open method is called with a block.
  
Using the *write* method:

#+BEGIN_SRC ruby
irb(main):003:0> File.open("simple_file.txt", "w") {|file| file.write("adding first line of text") }
File.open("simple_file.txt", "w") {|file| file.write("adding first line of text") }
=> 25
#+END_SRC

Using the *w* option, this opens the file and invokes a block to write content to the file. As we've seen, writing a file with a block automatically closes the file.

#+BEGIN_SRC ruby
irb(main):005:0> File.read("simple_file.txt")
File.read("simple_file.txt")
=> "adding first line of text"

#+END_SRC

We can also open the file, write to it, and close it with the *puts* method:

#+BEGIN_SRC ruby
irb(main):006:0> my_file = File.new("simple_file.txt", "w+")
my_file = File.new("simple_file.txt", "w+")
=> #<File:simple_file.txt>
irb(main):007:0> sample = File.open("simple_file.txt", "w+")
sample = File.open("simple_file.txt", "w+")
=> #<File:simple_file.txt>
irb(main):008:0> sample.puts("another example of writing to a file.")
sample.puts("another example of writing to a file.")
=> nil
irb(main):009:0> sample.close
sample.close
=> nil
irb(main):010:0> File.read("simple_file.txt")
File.read("simple_file.txt")
=> "another example of writing to a file.\n"
#+END_SRC

Insert more text into *simple_file.txt*:

#+BEGIN_SRC ruby
irb(main):011:0> File.open("simple_file.txt", "a+") do |file|
File.open("simple_file.txt", "a+") do |file|
irb(main):012:1* file << "Here we are with a new ine of text"
file << "Here we are with a new ine of text"
irb(main):013:1> end
end
=> #<File:simple_file.txt (closed)>
irb(main):014:0> File.readlines("simple_file.txt").each do |line|
File.readlines("simple_file.txt").each do |line|
irb(main):015:1* puts line
puts line
irb(main):016:1> end
end
another example of writing to a file.
Here we are with a new ine of text
=> ["another example of writing to a file.\n", "Here we are with a new line of text"]
#+END_SRC

*Notes*
- The *a+* mode was used to open the file for reading and updating.
- The variable *file* was used as a placeholder for the file, to allow text to be appended with the shovel operator.
- The file was automatically closed after the operation (at the end of the block).
- Instead of using *<<*, it's possible to use *puts* or *write*.
  
#+BEGIN_SRC ruby
irb(main):001:0> File.open("simple_file.txt", "a+") do |file|
File.open("simple_file.txt", "a+") do |file|
irb(main):002:1* file.write "Writing to files in Ruby is simple."
file.write "Writing to files in Ruby is simple."
irb(main):003:1> end
end
=> 35
irb(main):004:0> 

irb(main):005:0* File.readlines("simple_file.txt").each_with_index do |line, line_num|
File.readlines("simple_file.txt").each_with_index do |line, line_num|
irb(main):006:1* puts "#{line_num}: #{line}"
puts "#{line_num}: #{line}"
irb(main):007:1> end
end
0: another example of writing to a file.
1: Here we are with a new line of text
2: Writing to files in Ruby is simple.
=> ["another example of writing to a file.\n", "Here we are with a new line of text\n", "Writing to files in Ruby is simple."]
#+END_SRC

** Deleting a File
We can delete files by passing the name or reference to a file to *File.delete*.

#+BEGIN_SRC ruby
irb(main):008:0> File.new("dummy_file.txt", "w+")
File.new("dummy_file.txt", "w+")
=> #<File:dummy_file.txt>

irb(main):009:0> File.delete("dummy_file.txt")
File.delete("dummy_file.txt")
=> 1
#+END_SRC

Deleting files in Ruby is just as permanent (and dangerous) as the *rm* command in a Unix-like environment. The file is unrecoverable, so be careful!

** Exercise 1
Let's take one file's contents as input and create a new transformed file as a result:
#+BEGIN_SRC ruby
irb(main):010:0> simple = File.read("simple_file.txt")
simple = File.read("simple_file.txt")
=> "another example of writing to a file.\nHere we are with a new line of text\nWriting to files in Ruby is simple."
irb(main):011:0> original = File.new("original_file.txt", "w+")
original = File.new("original_file.txt", "w+")
=> #<File:original_file.txt>
irb(main):012:0> File.open(original, "a") do |file|
File.open(original, "a") do |file|
irb(main):013:1* file.puts simple
file.puts simple
irb(main):014:1> end
end
=> nil
irb(main):015:0> File.read(original)
File.read(original)
=> "another example of writing to a file.\nHere we are with a new line of text\nWriting to files in Ruby is simple.\n"

#+END_SRC

** Overview of File Classes

*** Files rule everything.
- Our programs and apps are built with files.
- Some files are the programs; others are the inputs/outputs of the programs.
- This complexity works when the *right stuff* is in the *right kind of files* in the *right place*.
  + The *right stuff* is the code that drives our programs.
  + The *right kind of files* is the format or extension of the file.
  + The *right place* is in a recognizable directory structure or Path.
    
Ruby's File class has an *IO* subclass, which handles bidirectional streams of data. Other well-known IO streams include: 

- *STDIN* (standard input)
- *STDOUT* (standard output)
- *STDERR* (standard error)
  
#+BEGIN_SRC ruby
irb(main):016:0> File.superclass
File.superclass
=> IO
irb(main):017:0> $stdin
$stdin
=> #<IO:<STDIN>>
irb(main):018:0> $stdout
$stdout
=> #<IO:<STDOUT>>
irb(main):019:0> $stderr
$stderr
=> #<IO:<STDERR>>

#+END_SRC

*Andrew's comment:* using this *superclass* method is a great resource! For example, I can verify that the *Array class* is a subclass of *Object*:
#+BEGIN_SRC ruby
irb(main):020:0> Array.superclass
Array.superclass
=> Object
#+END_SRC

In addition to the *File* class we've used so far, Ruby provides other classes for dealing with files:

- [[http://ruby-doc.org/core-2.1.3/Dir.html#method-i-to_path][Dir]]: Useful for working with directories and their contents. Shares many of File's methods, but it is not an IO stream.
- [[http://www.ruby-doc.org/stdlib-2.1.3/libdoc/pathname/rdoc/Pathname.html][Pathname]]: Exposes almost all of the methods supported by *File* and *Dir*. It's primary advantage is that you can declare an instance of it and access the methods from both the *File* and *Dir* methods on the same instance object.
  
*Authors' Note:* Depending on your particular Ruby installation, you may need to require Pathname before you can use it. We have included this in the example, just in case. If the return value from the require statement is false, that just means that Pathname was already available ([[http://www.gotealeaf.com/books/ruby/read/files#overviewfileclasses][Source]]).

#+BEGIN_SRC ruby
irb(main):025:0> require 'pathname'
require 'pathname'
=> true
irb(main):026:0> f = File.new("simple_file.txt", "r")
f = File.new("simple_file.txt", "r")
=> #<File:simple_file.txt>
irb(main):027:0> pn = Pathname.new(f)
pn = Pathname.new(f)
=> #<Pathname:simple_file.txt>
irb(main):028:0> pn.extname
pn.extname
=> ".txt"
irb(main):029:0> File.extname("simple_file.txt")
File.extname("simple_file.txt")
=> ".txt"

#+END_SRC

The example above created a file instance, and then used an instance of *Pathname* to find the extension. We could also do this by calling the *File::extname* method:

#+BEGIN_SRC ruby
irb(main):030:0> File::extname("simple_file.txt")
File::extname("simple_file.txt")
=> ".txt"
#+END_SRC

** Exercise 2
Look at the current directory and report the files that have *.txt* extensions

#+BEGIN_SRC ruby
irb(main):032:0> d = Dir.new(".")
d = Dir.new(".")
=> #<Dir:.>
irb(main):033:0> while file = d.read do
while file = d.read do
irb(main):034:1* puts "#{file} has extension .txt" if File.extname(file) == ".txt"
puts "#{file} has extension .txt" if File.extname(file) == ".txt"
irb(main):035:1> end
end
original_file.txt has extension .txt
simple_file.txt has extension .txt
=> nil
#+END_SRC

We can also do this by using the *Pathname* class (remember to *require 'pathname' first, if needed).

#+BEGIN_SRC ruby
irb(main):039:0> require 'pathname'
require 'pathname'
=> false

irb(main):040:0> pn = Pathname.new(".")
pn = Pathname.new(".")
=> #<Pathname:.>

irb(main):041:0> pn.entries.each { |f| puts "#{f} has extension .txt" if f.extname == ".txt" }
pn.entries.each { |f| puts "#{f} has extension .txt" if f.extname == ".txt" }
original_file.txt has extension .txt
simple_file.txt has extension .txt
=> [#<Pathname:.>, #<Pathname:..>, #<Pathname:original_file.txt>, #<Pathname:simple_file.txt>]
#+END_SRC
()In the example above, when I required 'pathname', it came back 'false' because I'd already required.)

** Working with file formats - CSV, Excel, JSON, XML

*** CSV and XLS/XLSX
- Commonly used to export/import tabular data.
- I often use these to export SQL data, as well as run statistical data in R in my job.
- Most people use Excel to open .csv files, but I often use Emacs or [[http://www.r-project.org][R]]. When I need to see the data in 'spreadsheet form, I also use the plain text/spreadsheet capabilities in [[http://orgmode.org/worg/org-tutorials/org-spreadsheet-intro.html][Emacs Org-Mode]].
  
We can access .csv files in Ruby with the built-in [[http://ruby-doc.org/stdlib-2.1.3/libdoc/csv/rdoc/index.html][CSV Class]] in the Ruby Standard Library.

For Excel (.xls/.xlsx) files, we can use [[https://github.com/randym/axlsx][axlsx]] to provide Ruby with the ability to access and export to Excel file formats. (Note for Rails: use *acts_as_axlsx*)...

*** JSON and XML/HTML
- These formats help us describe data that is nested, or doesn't 'fit into a box' the way tabular data usually does.
- [[http://json.org][JSON]] stands for JavaScript Object Notation.
  
Exercise 3 will deal with an article, which has three fields: 
1. *title*
2. *link*
3. *summary*
   
A newspaper and an article might be represented in JSON like this:

#+BEGIN_SRC javascript
      {
      "newspaper_name": "Cooking Today",
      "issue_date": "November 15th, 2014",
      "articles": [
          {
              "title": "Bacon Cooking",
              "link": "http:/baconcooklove.com",
              "summary": "Just a few thousand ideas about bacon"
          },
          {
              "title": "Cooking with leftovers",
              "link": "http://love.com",
              "summary": "Just a few thousand ides about tasting love twice"
          }
      ]
      }
  
#+END_SRC

Like hashes, JSON employs a key/value pair format, but it is a file that must be parsed and converted to a Ruby hash format. The standard Ruby library supports JSON. See Exercise 3, below, for an example of how to use JSON in a Ruby project.

[[http://www.w3.org/XML/][XML]], or *Extensible Markup Language is a useful tool for defining domain-specific schematics. HTML is an specialized form of XML. (OPML is another one that I indirectly use everyday, in my RSS feed reader).

The JSON file above might look like this in XML:

#+BEGIN_SRC html

<newspaper>
  <name>Cooking Today</name>
  <issue_date>November 15th, 2014</issue_date>
  <articles>
    <article>
      <title>Bacon Cooking</title>
      <link>http://baconcooklove.com</link>
      <summary>Just a few thousand ideas about bacon</summary>
    </article>
    <article>
      <title>Cooking with leftovers</title>
      <link>http://love.com</link>
      <summary>Just a few thousand ideas about tasting love twice</summary>
    </article>
  </articles>
</newspaper>

#+END_SRC
[[http://www.nokogiri.org][Nokogiri]] is a good Ruby gem for parsing XML and web pages.

** Exercise 3
To wrap up this chapter we are going to work through an exercise that will show us how to interact with these common file types. We will pull news articles from two different sources. One in XML format. One in JSON. We will combine the two lists to a common format, sort them, and save them to CSV and XLS files.

Let's get started. In your command line run these two commands.

#+BEGIN_SRC sh
$ wget -O feedzilla.json http://api.feedzilla.com/v1/categories/8/articles.json
$ wget -O slashdot.xml http://rss.slashdot.org/Slashdot/slashdot

#+END_SRC

Following the text's instructions, I peeked at the these two files: 

#+BEGIN_SRC sh
$ cat feedzilla.json
$ cat slashdot.xml
#+END_SRC

Lots of data. I'm not going to copy the output here.

Next, install the *axlsx gem*:
#+BEGIN_SRC sh
小A曰:gem install axlsx

#+END_SRC
I already had nokogiri installed, but this failed for me until I updated from 2.1.2 to 2.1.3 and set 'rbenv global 2.1.3'.

I read that there was a conflict with openssl, but that it had been resolved. I'd been meaning to update my environment, so I cleaned up and updated my installed gems and updated my Ruby, and that seemed to fix it. For future reference, here's the error I got:

#+BEGIN_SRC sh
小A曰:gem install axlsx
ERROR:  Loading command: install (LoadError)
	dlopen(/usr/local/var/rbenv/versions/2.1.2/lib/ruby/2.1.0/x86_64-darwin13.0/openssl.bundle, 9): Symbol not found: _SSLv2_client_method
  Referenced from: /usr/local/var/rbenv/versions/2.1.2/lib/ruby/2.1.0/x86_64-darwin13.0/openssl.bundle
  Expected in: /usr/local/opt/openssl/lib/libssl.1.0.0.dylib
 in /usr/local/var/rbenv/versions/2.1.2/lib/ruby/2.1.0/x86_64-darwin13.0/openssl.bundle - /usr/local/var/rbenv/versions/2.1.2/lib/ruby/2.1.0/x86_64-darwin13.0/openssl.bundle
ERROR:  While executing gem ... (NoMethodError)
    undefined method `invoke_with_build_args' for nil:NilClass
#+END_SRC

After updating my Ruby version and gems, I was able to finish the exercise.

*Note:* The output for each of these steps is really too long to paste here, but all of the files are in the '09_files' subdirectory. I've also included direct links to each file at the very end of this exercise.

#+BEGIN_SRC ruby
irb(main):001:0> require 'json'
=> true
irb(main):002:0> require 'nokogiri'
=> true
irb(main):003:0> require 'axlsx'
=> true
irb(main):004:0> require 'csv'
=> true
#+END_SRC

Next, open the XML file, find the items, and parse them with nokogiri:

#+BEGIN_SRC ruby
irb(main):010:0> slashdot_articles = []
=> []
irb(main):011:0> File.open("slashdot.xml", "r") do |f|
irb(main):012:1*   doc = Nokogiri::XML(f)
irb(main):013:1>   slashdot_articles = doc.css('item').map { |i|
irb(main):014:2*     {
irb(main):015:3*       title: i.at_css('title').content,
irb(main):016:3*       link: i.at_css('link').content,
irb(main):017:3*       summary: i.at_css('description').content
irb(main):018:3>     }
irb(main):019:2>   }
irb(main):020:1> end


#+END_SRC

*** The authors explain:

"At this point, the *slashdot_articles* array should be populated with the articles from the slashdot XML RSS feed. We have an array of hashes with fields we want to export. We found all the articles with the doc.css('item') call and then chained it through the map block to pull out the fields we want to export. We are ready to do a similar manauver on the *feedzilla.json* file" ([[http://www.gotealeaf.com/books/ruby/read/files#fileformats][Source]]).

And we do the same with the *feedzilla articles*:
#+BEGIN_SRC ruby
irb(main):026:0> feedzilla_articles = [ ]
=> []
irb(main):027:0> File.open("feedzilla.json", "r") do |f|
irb(main):028:1* items = JSON.parse(f.read)
irb(main):029:1> feedzilla_articles = items['articles'].map { |a|
irb(main):030:2* {
irb(main):031:3* title: a['title'],
irb(main):032:3* link: a['url'],
irb(main):033:3* summary: a['summary']
irb(main):034:3> }
irb(main):035:2> }
irb(main):036:1> end

irb(main):037:0> sorted_articles = (feedzilla_articles + slashdot_articles).sort_by {|a| a[:title]}
#+END_SRC

Now, we just need to write the two export files:

#+BEGIN_SRC ruby
irb(main):038:0> CSV.open("article.csv", "wb") do |csv|
irb(main):039:1* sorted_articles.each { |a| csv << [ a[:title], a[:link], a[:summary] ] }
irb(main):040:1> end

#+END_SRC

#+BEGIN_SRC ruby
irb(main):041:0> pkg = Axlsx::Package.new
=> #<Axlsx::Package:0x007fdf79859c78 @workbook=nil, @app=#<Axlsx::App:0x007fdf79859b10>, @core=#<Axlsx::Core:0x007fdf79859bd8 @creator="axlsx", @created=nil>>
irb(main):042:0> pkg.workbook.add_worksheet(:name => "Articles") do |sheet|
irb(main):043:1* sorted_articles.each { |a| sheet.add_row [a[:title], a[:link], a[:summary]]
irb(main):044:2> }
irb(main):045:1> end

#+END_SRC

#+BEGIN_SRC ruby
irb(main):046:0> pkg.serialize("articles.xlsx")
=> true

#+END_SRC
*** Source RSS/XHML Files
[[file:09_files/feedzilla.json][feedzilla.json]]
[[file:09_files/slashdot.xml][slashdot.xml]]

*** Output CSV/XLSX Files
[[file:09_files/article.csv][article.csv]]
[[file:09_files/articles.xlsx][articles.xlsx]]

** Summary
In this chapter, we learned how easy it is to work with Ruby files. Assuming that we have the proper permissions, and that the files are correctly formatted, we should be able to open and edit them within Ruby, using tools from the Ruby standard library, as well as supplemental Ruby gems.
