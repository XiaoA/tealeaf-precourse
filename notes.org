#+TITLE: Andrew's Learn Ruby Notes
#+AUTHOR: Andrew Buckingham
#+STARTUP: indent
#+OPTIONS: num:nil
#+OPTIONS: html-postamble:nil
#+TODO: TODO(t) | Started(s) | Waiting(w) | Canceled(c) | DONE(d)(@) | Questions(q) | Note(n)

* Preparation

** Exercise 1
Create a directory named my_folder and then navigate inside that directory. Create two files named one.rb and two.rb in the my_folder directory. Write a ruby program that outputs the line this is file one when you run the one.rb file. Then write another program that outputs this is file two when you run the two.rb file. (Hint: one.rb should have this in it puts "this is file one")
*** Solution

   #+BEGIN_SRC ruby
     # one.rb
     puts "this is file one"
        #+END_SRC

   #+BEGIN_SRC ruby
     # two.rb
   puts "this is file two"
   #+END_SRC


** Exercise 2
When you are finished with the above and both programs are working correctly, navigate to the directory above the my_folder directory and delete all of the content you generated with one command.
*** Solution
#+BEGIN_SRC sh
小A曰:ls
one.rb	two.rb
小A曰:cd ..
小A曰:ls
my_folder
小A曰:rm -R my_folder/
小A曰:ls
小A曰:
#+END_SRC

* The Basics
** Strings
   - Strings can use either double quotes ("") or single quotes (''), and you can escape quotes, when necessary ('This is Andrew\'s string.')
   - String interpolation (concatenation) *only works with double quotes*
     - Syntax: "Here's how to use string interpolation with a #{Ruby Expression}"
       *Example:*       

   #+BEGIN_SRC ruby 
a = 'ten'
"My favorite number is #{a}!"
   #+END_SRC
** Symbols
- You can use symbols to reference things, like strings, that you don't intend to print or edit.
- Often referred to as "immutable" (though this is apparently not 100% correct)

#+BEGIN_SRC ruby
# Examples of symbols
:name
:a_symbol
:"surprisingly, this is also a symbol" 
   #+END_SRC

** Numbers
Integers do not contain decimal points. Floats do.
  
*** Integers
    9, 1, 4, 1000

*** Floats
    9.1, 44.44409, 9.01234

** nil
The *nil* variable allows us to express an /empty value/ (it equals nothing). Ruby also outputs nil when an expected value is not returned.

In this example, puts prints out a statement, but returns nothing (nil):

   #+BEGIN_SRC ruby
# An example from irb

irb(main):006:0> puts "I love Ruby!"
puts "I love Ruby!"
I love Ruby!
=> nil
irb(main):007:0> 
   #+END_SRC

We can also check to see if a value is equal to nil:

#+BEGIN_SRC ruby
nil.nil?
=> true
irb(main):008:0> "nil".nil?
"nil".nil?
=> false
irb(main):009:0> 0.nil?
0.nil?
=> false
irb(main):010:0> "nothing".nil?
"nothing".nil?
=> false

# Note that following is also false:
irb(main):011:0> false == nil
false == nil
=> false

#+END_SRC

As expected, in the first example, *nil* is equal to 'nil', but strings or numbers (including the string, "nil" have a value, and so they cannot equal the empty value of nil.

When nil is used in a condtional expression, rather than as output, the result will be treated as false, because the value is not empty. Note these examples from the text:

#+BEGIN_SRC ruby
# The xpression is not empty, so it is false.
irb :001 > if nil
irb :002 > puts "Hello, World!"
irb :003 > end
=> nil

# The expression runs, and the output is nil.
irb :001 > if 1
irb :002 > puts "Hello, World!"
irb :003 > end
Hello, World!
=> nil
#+END_SRC

** Operations (Mathematical)
   These work as I would expect (similar to JavaScript).
*** Adding, Subtracting, and Multiplying Integers

*Addition (+)*
    #+BEGIN_SRC ruby
2 + 2
=> 4
    #+END_SRC

    #+RESULTS:
    : 4

*Subtraction (-)*
    #+BEGIN_SRC ruby
49 - 47
=> 2
    
    #+END_SRC

    #+RESULTS:
    : 2

*Multiplication (*)*
#+BEGIN_SRC ruby
144 * 144
=> 20736    
    #+END_SRC

    #+RESULTS:
    : 20736

** Division vs. Modulus

*** Division (/)
    #+BEGIN_SRC ruby
144 / 2
=> 2
    #+END_SRC

    #+RESULTS:
    : 72

*** Modulo
    #+BEGIN_SRC ruby
16 / 4
=> 0

16 / 3
=> 5
    
    #+END_SRC

    #+RESULTS:
    : 5

*** Multiplying Floats and Decimals
    #+BEGIN_SRC ruby
15.0 / 4
=> 3.75

48.0 * 7.2
=> 345.6

    
    #+END_SRC

    #+RESULTS:
    : 3.75

*** Equality Comparison

    #+BEGIN_SRC ruby
4 == 4
=> true

4 == '4'
=> false
      
'book' == "book"
=> true

'four' == 4
=> false

'four' == '4'
=> false

    #+END_SRC

    #+RESULTS:
    : false

*** String Concatenation
    #+BEGIN_SRC ruby
"I love" + " Ruby!"
    
    #+END_SRC

    #+RESULTS:
    : I love Ruby!

#+BEGIN_SRC ruby
"1" + "1" 
#+END_SRC

#+RESULTS:
: 11

    *We cannot concatenate a string and a number*

#+BEGIN_SRC ruby
1 + "Love"
#+END_SRC    

#+RESULTS:
-:3:in `+': String can't be coerced into Fixnum (TypeError)
	from -:3:in `main'
	from -:5:in `<main>'

** Basic Data Structures
   
*** Arrays

    #+BEGIN_SRC ruby
[1,2,3,4]
    
    #+END_SRC

    #+RESULTS:
    | 1 | 2 | 3 | 4 |

    Predictably, the index starts with 0:

    #+BEGIN_SRC ruby
irb(main):012:0> [1, 2, 3, 4] [0]
[1, 2, 3, 4] [0]
=> 1
irb(main):013:0* [1, 2, 3, 4] [1]
[1, 2, 3, 4] [1]
=> 2
irb(main):014:0> [1, 2, 3, 4] [2]
[1, 2, 3, 4] [2]
=> 3
irb(main):015:0> [1, 2, 3, 4] [3]
[1, 2, 3, 4] [3]
=> 4
irb(main):016:0> [1, 2, 3, 4] [4]
[1, 2, 3, 4][4]
=> nil 
    #+END_SRC
In the example above, there is no 4th index, so the result is nil.
    
*** Hashes {}
    - Function as dictionary/key-value pairs
    - consists of a *key* and a *value*.
      + The key is usually represented by a *:symbol*.
      + The value follows the *=>*.

        
#+BEGIN_SRC ruby
irb(main):019:0> {:dog => 'barks'}
{:dog => 'barks'}
=> {:dog=>"barks"}
irb(main):020:0> {:dog => 'barks', :cat => 'meows', :pig => 'oinks'}
{:dog => 'barks', :cat => 'meows', :pig => 'oinks'}
=> {:dog=>"barks", :cat=>"meows", :pig=>"oinks"}
#+END_SRC

We can retrieve any value by its key:    
#+BEGIN_SRC ruby
# Can you spot the error?
irb(main):021:0> 
{dog => 'barks', :cat => 'meows', :pig => 'oinks'}[:cat]
NameError: undefined local variable or method `dog' for main:Object
	from (irb):21
	from /usr/bin/irb:12:in `<main>'
#+END_SRC

In the example above, I forgot to add the ':' before 'dog'. Remember that strings require single or double quotes, and symbols require colons. Without either of these, your statements will throw an error.

I've fixed the error. Now we can search for the sound a cat makes:

#+BEGIN_SRC ruby
irb(main):022:0> {:dog => 'barks', :cat => 'meows', :pig => 'oinks'}[:cat]
{:dog => 'barks', :cat => 'meows', :pig => 'oinks'}[:cat]
=> "meows"{:cat => 'meows'}
#+END_SRC      

Many coding errors are just tiny punctuation or spacing errors. Syntax highlighting can help point those out, but experience reading error messages and a sharp eye are essential traits. For example, I remember once, when I was trying to debug a CSS file, it took me forever to figure out why it wasn't working. It turns out I'd used a colon instead of a semi-colon. Lesson learned...

** Expressions and Return
   - When you use the IRB, you'll see the 'hash rocket': *=>*
   - Everything in Ruby is an expression, and it always returns something, even if only /nil/

*** Puts vs. Return
    - puts: Ruby puts something on the screen, but it doesn't return what is printed to the screen. For example, *do* does something, but it also returns a value. Puts does not return the value.

      In these examples, *put* /prints/ a value to the screen, but it /returns/ nil:

      #+BEGIN_SRC ruby
irb(main):023:0> puts 'stuff'
puts 'stuff'
stuff
=> nil
irb(main):024:0> a = puts 'stuff'
a = puts 'stuff'
stuff
=> nil
irb(main):025:0> puts a
puts a
=> nil
#+END_SRC
      
*** Exercises

**** Problem 1
Add two strings together that, when concatenated, return your first and last name as your full name in one string.

For example, if your name is John Doe, think about how you can put "John" and "Doe" together to get "John Doe".

**** Solution 1
Here are three ways. The first is the one I came up with. It can be run in irb:     
#+BEGIN_SRC ruby
irb(main):026:0> "Andrew " + "Buckingham"
"Andrew " + "Buckingham"
=> "Andrew Buckingham"
#+END_SRC
(Note the space after "Andrew ").

The solution came up with two other ways, by assigning variables in the first case, and using string interpolation in the second:

#+BEGIN_SRC ruby :tangle 02_basics/solution1.rb
# #1: My original, (overly?) simple solution
puts "Andrew " + "Buckingham" # Andrew Buckingham

# #2: From the books's solution; assigns variables and then concatenates them:

fname = "Andrew"
lname = "Buckingham"

puts fname + " " + lname

# #3: From the book's solution; using string interpolation:
puts "#{fname} #{lname}"

#+END_SRC

File: [[file:02_basics/solution1.rb][02_basics/solution01.rb]]
#+BEGIN_SRC sh
# See 02_basics/solution01.rb for Ruby file.
小A曰: ruby solution1.rb 
Andrew Buckingham
Andrew Buckingham
Andrew Buckingham

#+END_SRC



**** Problem 2
2. Use the modulo operator, division, or a combination of both to take a 4 digit number and find 1) the thousands number 2) the hundreds 3) the tens and 4) and the ones.
     
**** Solution 2

#+BEGIN_SRC ruby :tangle 02_basics/solution2.rb
puts 6732 / 1000
puts 6732 % 1000 / 100
puts 6732 % 1000 % 100 / 10
puts 6732 % 1000 %100 % 10     
#+END_SRC

Output: [[file:02_basics/solution2.rb][02_basics/solution2.rb]]
#+BEGIN_SRC sh
小A曰:ruby solution2.rb 
6
7
3
2
#+END_SRC

I'll be honest. I didn't quite understand what I was supposed to do, until I saw the solution. I understood the modulo, because it's the same in JavaScript, and once I saw it, the directions made sense. But this was a fun exercise; it's a very simple preview of the kinds of problem-solving tasks that I'll become better at with practice!

**** Problem 3
Write a program that uses a hash to store a list of movie titles with the year they came out. Then use the *puts* command to make your program print out the year of each movie to the screen. The output for your program should look something like this:

#+BEGIN_SRC ruby
1975
2004
2013
2001
1981
#+END_SRC
**** Solution 3
#+BEGIN_SRC ruby :tangle 02_basics/solution3.rb
       movies = {:The_Empire_Strikes_Back =>'1980',
         :The_Dark_Knight => '2008',
         :Avatar => '2009',
         :The_Blind_Side => '2009',
         :Into_the_Fire => '2010'}  

       puts movies[:The_Empire_Strikes_Back]
       puts movies[:The_Dark_Knight]
       puts movies[:Avatar]
       puts movies[:The_Blind_Side]
       puts movies[:Into_the_Fire]
     #+END_SRC

File: [[file:02_basics/solution3.rb][02_basics/solution3.rb]]
#+BEGIN_SRC sh
小A曰:ruby solution3.rb
1980
2008
2009
2009
2010
#+END_SRC

**** Problem 4
Use the dates from the previous example and store them in an array. Then make your program output the same thing as exercise 3.

File: [[file:02_basics/solution4.rb][02_basics/solution4.rb]]

**** Solution 4
#+BEGIN_SRC ruby :tangle 02_basics/solution4.rb
# My solution
years = [1980, 2008, 2009, 2009, 2010]
puts years

# Book solution
dates = [1980, 2008, 2009, 2009, 2010]

puts dates[0]
puts dates[1]
puts dates[2]
puts dates[3]
puts dates[4]
#+END_SRC

***** TODO Find out if there is a difference between our solutions in practical coding situations
*Note:* My solution looks the same as the book's but I can understand the difference in our approach. My reasoning was that if I created a variable (years), I could call that variable, and it would list the dates. The book calls each index, one at a time. Although the output was the same for me, I wonder if there might be a situation where mine would not work well.

**** Problem 5
Write a program that outputs the factorial of the numbers 5, 6, 7, and 8.
**** Solution 5
I need to create a program that outputs something like this:

#+BEGIN_SRC ruby
puts 5 * 4 * 3 * 2 * 1 
puts 6 * 5 * 4 * 3 * 2 * 1
puts 7 * 6 * 5 * 4 * 3 * 2 * 1
puts 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1
#+END_SRC

It seems like that works in irb. But perhaps I could make it a bit more elegant with variables.

#+BEGIN_SRC ruby :tangle 02_basics/solution5.rb
# Write a program that outputs the factorial of the numbers 5, 6, 7, and 8.
# My solution
five = 5 * 4 * 3 * 2 * 1
six = 6 * 5 * 4 * 3 * 2 * 1
seven = 7 * 6 * 5 * 4 * 3 * 2 * 1
eight = 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1

puts five
puts six
puts seven
puts eight

# Book solution
puts 5 * 4 * 3 * 2 * 1 
puts 6 * 5 * 4 * 3 * 2 * 1
puts 7 * 6 * 5 * 4 * 3 * 2 * 1
puts 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1

# This is the same as what I first came up with, but then I decided to assign variables...

#+END_SRC
***** Note 
It looks like my first instinct was correct; the book came up with the same answer. I suppose the one advantage of using variables would be that I could use them again, if needed.

**** Problem 6
Write a program that calculates the squares of 3 float numbers of your choosing and outputs the result to the screen.

*File:* [[file:02_basics/solution6.rb][02_basics/solution6.rb]]
**** Solution 6
#+BEGIN_SRC ruby :tangle 02_basics/solution6.rb
# Calculate the squares of 3 float numbers of your choosing and outputs the result to the screen.
puts 40.3 * 40.3
puts 59.5959 * 59.5959
puts 999.99191874 * 999.99191874
#+END_SRC

*Bonus*
This summer, I learned the 'get.chomps' method. I think I could use that to create an interactive program here, that asks the user to provide the floats...

*File:* [[file:02_basics/solution6_bonus.rb][02_basics/solution6_bonus.rb]]
#+BEGIN_SRC ruby :tangle 02_basics/solution6_bonus.rb
# Asks user to provide three floats and then outputs the result to the screen.

puts "Please provide three numbers, with decimal points and at least one digit."
first_number = gets.chomp.to_f
second_number = gets.chomp.to_f
third_number = gets.chomp.to_f

puts "I will now give you the squares and cubes of each of the numbers you have provided."


puts "The square of the first number is #{first_number * first_number}. The cube is  #{first_number * first_number * first_number}."
puts "The square of the second number is #{second_number * second_number}. The cube is #{second_number * second_number * second_number}."
puts "The square of the third number is #{third_number * third_number}. The cube is #{third_number * third_number * third_number}."

#+END_SRC
I had trouble getting that to work, because I was trying to concatenate everything, so it kept throwing errors. The lines looked like this:

#+BEGIN_SRC ruby
puts "The square of the first number is " first_number * first_number "." "The cube is " first_number * first_number * first_number "."
#+END_SRC

Based on my experience with JavaScript, that seemed to make sense to me, but I kept getting errors similar to this:

#+BEGIN_SRC sh
solution6_bonus.rb:9:in `+': no implicit conversion of Float into String (TypeError)
	from solution6_bonus.rb:9:in `<main>'
#+END_SRC

I checked the Ruby documentation, and had decided that the problem was that I wasn't using the correct syntax to put strings and variables on the same line. A simple searched revealed the answer: string interpolation! See this link: http://stackoverflow.com/questions/13526847/ruby-puts-string-and-integer-on-same-line

I just thought of one more way to improve the program. Instead of saying, "The square of the first number is..." I can use string interpolation to show the user the number he/she entered.

*File:* [[file:02_basics/solution6_bonus_improved.rb][02_basics/solution6_bonus_improved.rb]]
#+BEGIN_SRC ruby :tangle 02_basics/solution6_bonus_improved.rb
puts "Please provide three numbers, with decimal points and at least one digit."
first_number = gets.chomp.to_f
second_number = gets.chomp.to_f
third_number = gets.chomp.to_f

puts "I will now give you the squares and cubes of each of the numbers you have provided."


puts "The square of #{first_number} is #{first_number * first_number}. The cube is  #{first_number * first_number * first_number}."
puts "The square of #{second_number} is #{second_number * second_number}. The cube is #{second_number * second_number * second_number}."
puts "The square of #{third_number} is #{third_number * third_number}. The cube is #{third_number * third_number * third_number}."

#+END_SRC

And here's the solution from the book:

#+BEGIN_SRC ruby
puts 4.30 * 4.30
puts 6.13 * 6.13
puts 124.34 * 124.34
#+END_SRC

That was a bit of a detour, but I learned a valuable lesson. And it was really fun to solve that problem!
**** Problem 7
What does the following error message tell you?

#+BEGIN_SRC sh
SyntaxError: (irb):2: syntax error, unexpected ')', expecting '}' from /usr/local/rvm/rubies/ruby-2.0.0-rc2/bin/irb:16:in `<main>' 
#+END_SRC
**** Solution 7

*My solution:* "The coder typed a ')' instead of a '}' (probably when closing a hash)."

*The book's solution:* "There is an opening bracket somewhere in the program without a closing bracket following it. It may have happened when creating a hash."

* Variables
- Use this syntax when assigning variables: <variable_name> = <variable value>
- Be careful to assign a variable names that are unique, and yet easy for others (or you, at a later date) to understand.
- Variables contain information that we can use again, and are a useful way to abstract data. As the author reminds us, "It is helpful to think of variables as containers that hold information. Their sole purpose is to label and store data in memory. This data can then be used throughout your program."

** Assigning Value to Variables
   - Use descriptive/understandable variable names
   - Use '=' for assignment.
   - Use snake_case for variable names.
   - '=' is an assignment operator. '==' is an equality variable. Be careful not to confuse them. /(Unlike JS, Ruby does not appear to have a '===' operator.)/

#+BEGIN_SRC ruby
irb(main):032:0* first_name = "Andrew"
first_name = "Andrew"
=> "Andrew"

#+END_SRC

Now, when we call the variable:

#+BEGIN_SRC ruby
irb(main):033:0> first_name
first_name
=> "Andrew"

#+END_SRC

- "Variables point to values in memory."
- The value *Andrew* is a string. We can reference that in our program by calling the variable, *first_name*
   #+BEGIN_SRC ruby
a = 4
# 4

b = a
# 4

a = 7
# 7

b

# b still equals 4, even though variable a = 7.
   
   #+END_SRC

** Variable Scope
- Defined by where the variable was created/initialized
- Determined by blocks
  
*** *Inner scope can access variables initialized in an outer scope, but not vice versa.*

#+BEGIN_SRC ruby
# scope.rb

a = 5 # variable is initialized in the outer scope
3.times do |n| a = 3 # is a accessible here, in an inner scope?
end puts a 

# a = 3
#+END_SRC    

    Another example:

#+BEGIN_SRC ruby
# scope.rb
a = 5

3.times do |n|
  a = 3
  b = 5 # b is initialized in the inner scope
end

puts a
puts b

# is b accessible here, in the outer scope? 
    
#+END_SRC

It didn't work. I got the following error:

#+BEGIN_SRC sh
scope.rb:10:in `<main>': undefined local variable or method `b' for main:Object (NameError)
    
#+END_SRC

According to the book: This is because the variable b is not available outside of the do/end block in which it is initialized. When we call puts b it is not available within that outer scope.

/(This isn't a surprise. I've seen the same behavior in JS.)/

Another example, with a method:
#+BEGIN_SRC ruby
a = 5

def some_method
a = 3
end

puts a

# a = 5
#+END_SRC

From the text:

"What's the value of a? Still 5, because methods create their own scope that's entirely outside of the execution flow. We'll cover this in more detail when we talk about methods, but for now, make sure you don't mix up do/end with methods when you're working with variable scope issues.

*Note: the key distinguishing factor for deciding whether code delimited by {} or do/end is considered a block (and thereby creating a new scope for variables), is seeing if the {} or do/end immediately follows a method invocation.*

For example:

#+BEGIN_SRC ruby
arr = [1, 2, 3]

for i in arr do
  a = 5 # a is initialized here
end

puts a # is it accessible here? (A: Yes!)
    
#+END_SRC

In this case, *for...do/end* did not create a new inner scope, because these are part of standard Ruby language, and not method calls.

(!) New blocks are created when we use *each*, *times*, or other methods, followed by:
    - {}
    - do/end

    
** Exercises

*** Problem 1
Write a program called name.rb that asks the user to type in their name and then prints out a greeting message with their name included.

*File:* [[file:03_variables/name.rb][03_variables/name.rb]]
*** Solution 1

#+BEGIN_SRC ruby :tangle 03_variables/name.rb
# 03_variables/name.rb
# Asks user for his/her name, and prints it out with a greeting.

puts "What's your name?"
name = gets.chomp

puts 'Hello, ' + name + '!'

#+END_SRC

Here's the book's solution. Almost identical.

#+BEGIN_SRC ruby
# name.rb
puts "What is your name?"
name = gets.chomp
puts "Hello " + name
#+END_SRC


*** Problem 2
Write a program called age.rb that asks a user how old they are and then tells them how old they will be in 10, 20, 30 and 40 years. Below is the output for someone 20 years old.

#+BEGIN_SRC ruby
# output of age.rb for someone 20 yrs old
How old are you?
In 10 years you will be: 30
In 20 years you will be: 40
In 30 years you will be: 50
In 40 years you will be: 60

#+END_SRC

*** Solution 2

*File:* [[file:03_variables/age.rb][03_variables/age.rb]]
#+BEGIN_SRC ruby :tangle 03_variables/age.rb
# age.rb

puts "How old are you?"

age = gets.chomp.to_i

puts "In 10 years you will be: #{age + 10}"
puts "In 20 years you will be: #{age + 20}"
puts "In 30 years you will be: #{age + 30}"
puts "In 40 years you will be: #{age + 40}"

#+END_SRC

Here's the solution from the book. Mine's a bit different, but both work. The main difference is that my solution prints each statement on one line, and the book's prints each solution two lines. 
#+BEGIN_SRC ruby
puts "How old are you?" 
age = gets.chomp.to_i 
"In 10 years you will be:" 
puts age + 10 
puts "In 20 years you will be:" 
puts age + 20 
puts "In 30 years you will be:" 
puts age + 30 
puts "In 40 years you will be:" 
puts age + 40
#+END_SRC
**** Note 
A couple things:
1. I learned about the 'to.i' method this summer. It seems to be the equivalent of JavaScript's 'parseInt'. I'll need to look into this more.
2. Are there any practical differences to the way I solved the problem, vs. the way the book did?

*** Problem 3
Add another section onto name.rb that prints the name of the user 10 times. You must do this without explicitly writing the puts method 10 times in a row.

*** Solution 3

*File:* [[file:03_variables/name2.rb]]

#+BEGIN_SRC ruby :tangle 03_variables/name2.rb
# 03_variables/name2.rb (Version II; prints out the greeting ten times)
puts "What is your name?" 
name = gets.chomp 

10.times do
  puts name
end
#+END_SRC

*** Book Solution (Same)

#+BEGIN_SRC ruby
  # name.rb continued 
  10.times do 
    puts name 
  end
#+END_SRC

*Comments*
Yay! I got this right. :)

*** Problem 4
Modify name.rb again so that it first asks the user for their first name, saves it into a variable, and then does the same for the last name. Then outputs their full name all at once.

*** Solution 4


**** Version 1
*File:* [[file:03_variables/name3_version1.rb][03_variables/name3_version1.rb]]

#+BEGIN_SRC ruby :tangle 03_variables/name3_version1.rb
# 03_variables/name3_version1.rb (Version III; prints out full name

puts "What is your first name?" 
first_name = gets.chomp

puts "What is your last name?" 
last_name = gets.chomp 

puts first_name + " " + last_name

#+END_SRC

**** Version 2
*File:* [[03_variables/name3_version2.rb]]

#+BEGIN_SRC ruby :tangle 03_variables/name3_version2.rb
# name.rb (Version III; prints out full name, with interpolation)

puts "What is your first name?" 
first_name = gets.chomp

puts "What is your last name?" 
last_name = gets.chomp 

puts "#{first_name} #{last_name}"

#+END_SRC


**** Book Solution
#+BEGIN_SRC ruby
# name.rb continued again
puts "What is your first name?"
first_name = gets.chomp
puts "Thank you. What is your last name?"
last_name = gets.chomp
puts "Great. So your full name is " + first_name + " " + last_name

#+END_SRC

**** Comments
I didn't have any problems with this one. My name3_version1.rb file is about the same as the book's verison; name2_version2.rb uses string interpolation to achieve the same result.

*** Problem 5
Look at the following programs...

#+BEGIN_SRC ruby
  x = 0
  3.times do
    x += 1
  end
  puts x
#+END_SRC

and...

#+BEGIN_SRC ruby

  y = 0
  3.times do
    y+= 1
    x = y
  end
  puts x

#+END_SRC
What does x print to the screen in each case? Do they both give errors? Are the errors different? Why?

**** My Solution
*Here are my guesses before I test them...*
I think the first one will print '3', because 'X' is defined as '0', and then it is incremented three times. Because the variable is initialized globally, it will be available in the global scope.

X will cause an error in the second example, because 'x' is initialized within the '3.times do' local scope. (BTW, Y = 1)...

And now for the tests...

- I was right for the first one.

- I was also right for the second one. The exact error message was:

  #+BEGIN_SRC sh
test.rb:6:in `<main>': undefined local variable or method `x' for main:Object (NameError)
  
  #+END_SRC

*Here's the book's solution:*
The first prints 3 to the screen. The second throws an error undefined local variable or method because x is not available as it is created within the scope of the do/end block.

*Comments*
I was right, but I should have been a bit more precise with my answer for the second one. The nature of the error was 'undefined local variable or method.'

*** Problem 6
What does the following error message tell you?

#+BEGIN_SRC ruby
NameError: undefined local variable or method `shoes' for main:Object

from (irb):3

from /usr/local/rvm/rubies/ruby-2.0.0-rc2/bin/irb:16:in `<main>'

#+END_SRC

*** Solution 6
The variable 'shoes' was defined locally, and is therefore unavailable in the global scope.

*Here's the book's solution:*
"The program is trying to reference a variable or method named shoes that has not been defined in the program, or is outside of the scope in which it is being called."

* Methods

** What Are Methods and Why Do We Need Them?
- Most programming languages have procedures that allow you to abstract function calls (or other tasks), to make code cleaner and more readable. In Ruby, these are called *methods*.
- We can add parameters(x) to access data from outside the current scope.
  - Like variables, parameters should always have clear and easily-understandable names.
  - Parameters allow us to pass values into methods, which can allow us to make changees in one place, which can change many other parts of our code, as we'll see below.

Here is the basic syntax:
#+BEGIN_SRC ruby
  
  def say
    # method body goes here
  end
  
#+END_SRC

Using a method call, we can turn this redundant code:
#+BEGIN_SRC ruby

# say.rb

puts "hello"
puts "hi"
puts "how are you"
puts "I'm fine"

#+END_SRC

into this:

#+BEGIN_SRC ruby
    
    # say.rb refactored
    def say(words)
      puts words
    end

    say("hello")
    say("hi")
    say("how are you")
    say("I'm fine")
    
#+END_SRC

One advantage of using methods is that we can make a single change, which will make many changes in our program. For example, to add a period to each expresison:

#+BEGIN_SRC ruby
# say.rb refactored
def say(words)
puts words + '.' ## <= We only make the change here!
end
say("hello")
say("hi")
say("how are you")
say("I'm fine")

#+END_SRC

*** Aside
Taking this a step further, in irb, I grabbed the full array of available methods for strings:

#+BEGIN_SRC ruby
irb(main):001:0> "hello".methods.sort

=> [:!, :!=, :!~, :%, :*, :+, :<, :<<, :<=, :<=>, :==, :===, :=~, :>, :>=, :[], :[]=, :__id__, :__send__, :ascii_only?, :b, :between?, :bytes, :bytesize, :byteslice, :capitalize, :capitalize!, :casecmp, :center, :chars, :chomp, :chomp!, :chop, :chop!, :chr, :class, :clear, :clone, :codepoints, :concat, :count, :crypt, :define_singleton_method, :delete, :delete!, :display, :downcase, :downcase!, :dump, :dup, :each_byte, :each_char, :each_codepoint, :each_line, :empty?, :encode, :encode!, :encoding, :end_with?, :enum_for, :eql?, :equal?, :extend, :force_encoding, :freeze, :frozen?, :getbyte, :gsub, :gsub!, :hash, :hex, :include?, :index, :insert, :inspect, :instance_eval, :instance_exec, :instance_of?, :instance_variable_defined?, :instance_variable_get, :instance_variable_set, :instance_variables, :intern, :is_a?, :kind_of?, :length, :lines, :ljust, :lstrip, :lstrip!, :match, :method, :methods, :next, :next!, :nil?, :object_id, :oct, :ord, :partition, :prepend, :private_methods, :protected_methods, :public_method, :public_methods, :public_send, :remove_instance_variable, :replace, :respond_to?, :reverse, :reverse!, :rindex, :rjust, :rpartition, :rstrip, :rstrip!, :scan, :scrub, :scrub!, :send, :setbyte, :singleton_class, :singleton_method, :singleton_methods, :size, :slice, :slice!, :split, :squeeze, :squeeze!, :start_with?, :strip, :strip!, :sub, :sub!, :succ, :succ!, :sum, :swapcase, :swapcase!, :taint, :tainted?, :tap, :to_c, :to_enum, :to_f, :to_i, :to_r, :to_s, :to_str, :to_sym, :tr, :tr!, :tr_s, :tr_s!, :trust, :unpack, :untaint, :untrust, :untrusted?, :upcase, :upcase!, :upto, :valid_encoding?]

#+END_SRC

Then I capitalized each sentence:

#+BEGIN_SRC ruby
# say.rb refactored (plus, capitalized!)
def say(words)
  puts words.capitalize + "." # <= I added the 'capitalize' method, just for fun...
end

say("hello")
say("hi")
say("how are you")
say("I'm fine")

#+END_SRC

Here's the result:

#+BEGIN_SRC bash

Hello.
Hi.
How are you.
I'm fine.

#+END_SRC

*Learning to program is so much fun! :)* 

** Default Parameters
Default parameters allow us to write methods that work, even if no arguments are sent:

*File:* [[file:04_methods/say_refactored.rb][04_methods/say_refactored.rb]]
#+BEGIN_SRC ruby :tangle 04_methods/say_refactored.rb
  
  def say(words='hello')
    puts words + '.'
  end
  say()   # <= "hello."
  say("hi")
  say("how are you")
  say("I'm fine")
  
#+END_SRC

It works!

#+BEGIN_SRC sh
小A曰:ruby say_refactored.rb 
hello.
hi.
how are you.
I'm fine.
#+END_SRC

** Optional Parentheses
Many Rubyists leave off parentheses when using methods. So *say("hi")* could be written as *say "hi"*. This can make it hard to differentiate local variables and method names.

** obj.method or method(obj)
From the book:

"There are two ways to use methods that we will discuss in this book. The some_method(obj) format is when you send arguments to a method; in the previous example, obj is the argument being passed in to the some_method method. Sometimes, you will see methods called with an explicit caller, like this a_caller.some_method(obj). We will discuss this in more detail in part III on Object Oriented Programming. For now it's best to think of the previous code as some_method modifying a_caller. You'll have to memorize which way is required to call a method for now."

** Mutating the Caller (Permanently altering the argument)
Recall:
- method arguments are scoped
- method arguments are not available outside of the method
- methods cannot modify arguments permanently

*File:* [[file:04_methods/mutate.rb][04_methods/mutate.rb]]

#+BEGIN_SRC ruby :tangle 04_methods/mutate.rb
  def some_method(number)
    number = 7 # this is implicitly returned by the method (because it's scoped, it won't affect the global value of a).
  end
  
  a = 5
  some_method(a)
  puts a # <= '5'
  
  # a = 5
#+END_SRC


*** Aside
Just to test out what would happen, I made a change to the code on line 7. I added a 'puts' before 'some method(a), which allowed Ruby to print both the value of 'a' as an argument of *some_method* and as a global variable.

*File:* [[file:04_methods/mutate_test.rb][04_methods/mutate_test.rb]]
#+BEGIN_SRC ruby :tangle 04_methods/mutate_test.rb
  def some_method(number)
    number = 7 # this is implicitly returned by the method (because it's scoped, it won't affect the global value of a).
  end
  
  a = 5
  puts some_method(a) # <= I added a 'puts' here so that I could see the '7' 
  puts a # <= '5'
  
  # a = 5
#+END_SRC

*There is an exception to the rule!* We can perform actions that permanently change the argument (mutate the caller). For example:

*File:* [[file:04_methods/mutate_perm.rb][04_methods/mutate_perm.rb]]

#+BEGIN_SRC ruby :tangle 04_methods/mutate_perm.rb
# Example of a method that modifies its argument permanently
# 04_methods/mutate_perm.rb
a = [1, 2, 3]
def mutate(array)
  array.pop
end

p "Before mutate method: #{a}"
mutate(a)
p "After mutate method: #{a}"

# Result:
# "Before mutate method: [1, 2, 3]"
# "After mutate method: [1, 2]"

#+END_SRC

*** Comments
The authors point out that they use *p* instead of *puts* in this program. I ran it both ways, and here were the results:

**** *p*
"Before mutate method: [1, 2, 3]"

"After mutate method: [1, 2]"

**** *puts*
Before mutate method: [1, 2, 3]

After mutate method: [1, 2]

I spent some time learning at RubyMonk this summer, and I knew I'd seen a lesson about the difference between 'p' and 'puts'. The vernerable master explains, "*Puts* generally prints the result of applying to_s on an object while *p* prints the result of inspecting the object.

In other words, using 'p' is generally better for debugging, because it inspects the object..."p foo" is the same as "puts foo.inspect" (Source: http://stackoverflow.com/questions/1255324/p-vs-puts-in-ruby).

*** This method will not mutate the caller
#+BEGIN_SRC ruby
  # Example of a method that does not mutate the caller
  # mutate.rb
  
  a = [1, 2, 3]
  def no_mutate(array)
    array.last
  end
  
  p "Before no_mutate method: #{a}"
  no_mutate(a)
  p "After no_mutate method: #{a}"

# Results:
# "Before no_mutate method: [1, 2, 3]"
# "After no_mutate method: [1, 2, 3]"
  
#+END_SRC

Key points:
- The *last* method does not mutate the caller
- Some methods mutate the caller, and some do not. Unfortunately, you just have to memorize which do.
- Ruby is both a /pass-by-value/ and a /pass-by-reference/ language.
  
** puts vs. return: The Sequel

*File:* [[file:04_methods/mutate_sequel.rb][04_methods/mutate_sequel.rb]]
#+BEGIN_SRC ruby :tangle 04_methods/mutate_sequel.rb
# 04_methods/mutate_sequel.rb

a = [1, 2, 3]

def mutate(array)
  array.pop
end

p "Before mutate method:#{a}"    # a = [1, 2, 3]
p mutate(a)                      # 3 (popped value from array)
p "After mutate method:#{a}"     # a = [1, 2]
#+END_SRC

*Output*
#+BEGIN_SRC sh
小A曰:ruby mutate_sequel.rb 
"Before mutate method:[1, 2, 3]"
3
"After mutate method:[1, 2]"
#+END_SRC

Explanation:
1. Print out *a* as initially defined ([1,2,3] array)
2. Print out the value returned by the mutate method (array.pop)
3. Print out *a* afer the mutate method


Here's an example of *return*:

*File:* [[file:04_methods/return.rb][04_methods/return.rb]]
#+BEGIN_SRC ruby :tangle 04_methods/return.rb
# return.rb
def add_three(number)
number + 3
end

returned_value = add_three(4)
puts returned_value
#+END_SRC


I guessed it would be '7' and I was right!

Explanation from the book:

"Here we're saving the returned value of the add_three method in a variable called returned_value. Then we print returned_value to the output to see what it has inside it. Your output should print 7 because that's what the method returned."

"*Ruby methods ALWAYS return the evaluated result of the last line of the expression unless an explicit return comes before it.*" For example:
*File:* [[file:04_methods/return2.rb][04_methods/return2.rb]]
#+BEGIN_SRC ruby :tangle 04_methods/return2.rb

# return.rb
def add_three(number)
  return number + 3
end

returned_value = add_three(4)
puts returned_value

#+END_SRC

Output:

#+BEGIN_SRC sh
小A曰:ruby return2.rb 
7
#+END_SRC
*Comments*
I predicted the above formula would return 7. Return prints the value and stops without executing the next line.

*** Important Takeaway
Important feature of Ruby:
*"The 'return' reserved word is not required in order to return something from a method."

#+BEGIN_SRC ruby
    
  def just_assignment(number)
    foo = number + 3
  end

# The value of just_assignment(5) would be '8'
    
#+END_SRC

** Exercises

*** Problem 1
Write a program that contains a method called greeting that takes a name as its parameter. It then prints a greeting message with the name included in it.

*** Solution 1

*File:* [[file:04_methods/greeting.rb][04_methods/greeting.rb]]
#+BEGIN_SRC ruby :tangle 04_methods/greeting.rb
# 04_methods/greeting.rb

puts "What is your name?"
name = gets.chomp

def greeting(name)
  "Hello, " + name + "!" 
end

puts greeting(name)
#+END_SRC

*** Book Solution
#+BEGIN_SRC ruby
def greeting(name)
"Hello, " + name + ". How are you doing?"
end
puts greeting("Bob")

#+END_SRC


*Comments*
My version worked, but I focused on making it interactive, instead of on passing in an argument.

Here's a version that combines my solution with the authors':

*File:* [[file:04_methods/greeting_final.rb][04_methods/greeting_corrected.rb]]
#+BEGIN_SRC ruby :tangle 04_methods/greeting_corrected.rb

def greeting(name)
  "Hello, " + name + ". I think Ruby's pretty cool. How about you?"
end

puts greeting("Jon")
#+END_SRC


** Problem 2.
What do the following expressions evaluate to?

#+BEGIN_SRC ruby

1. x = 2
2. puts x = 2
3. p name = "Joe"
4. four = "four"
5. print something = "nothing"

#+END_SRC

** Solution 2

1. x will equal 2, but it won't print anything. 2
2. x will equal two, and it will evaluate to "2" and return nil
3. "Joe"
4. four will equal the string "four", but it won't print anything.
5. nothing
   
*** Book Solution
#+BEGIN_SRC ruby
1. x = 2 # => 2
2. puts x = 2 # nil
3. p name = "Joe" # => "Joe"
4. four = "four" # => "four"
5. print something = "nothing" # => nil

  #+END_SRC

#+BEGIN_SRC sh
print something = "nothing"

#+END_SRC

*** Solution 2

1. x will equal 2, but it won't print anything. 2
2. x will equal two, and it will evaluate to "2" and return nil
3. "Joe"
4. four will equal the string "four", but it won't print anything.
5. nothing
   
*** Book Solution
#+BEGIN_SRC ruby
1. x = 2 # => 2
2. puts x = 2 # nil
3. p name = "Joe" # => "Joe"
4. four = "four" # => "four"
5. print something = "nothing" # => nil

#+END_SRC

Just to be sure, I ran these through irb:

#+BEGIN_SRC sh

irb(main):002:0> x = 2
x = 2
=> 2
irb(main):003:0> puts x = 2
puts x = 2
2
=> nil
irb(main):004:0> "Joe"
"Joe"
=> "Joe"
irb(main):005:0> four = "four"
four = "four"
=> "four"
irb(main):006:0> print something
print something
nothing=> nil
irb(main):007:0> 

#+END_SRC

*** Problem 3
Write a program that includes a method called multiply that takes two arguments and returns the product of the two numbers.

*** Solution 3

*File:* [[file:04_methods/multiply.rb][04_methods/multiply.rb]]
#+BEGIN_SRC ruby :tangle 04_methods/multiply.rb

def multiply(a, b)
  a * b
end

puts multiply(5,3)

#+END_SRC

*** Book Solution

#+BEGIN_SRC ruby
  
  def multiply(number1, number2) 
    number1 * number2 
  end 
  puts multiply(4, 2)
  
#+END_SRC

*** Comments
My solution worked, and it was essentially the same thing, but I used 'a' and 'b' for arguments. 'number1' and 'number2' are more descriptive and would probably be better choices for arguments.

** Problem 4
What will the following code print to the screen?

#+BEGIN_SRC ruby
  def scream(words)
    words = words + "!!!!"
    return puts words
  end

  scream("Yippeee") 
  
#+END_SRC

*** Andrew's Answer
Nothing. When it hits the 'return' on the third line, it will stop evaluating the program.

*** Book Solution
It will not print anything to the screen. This is great, because I'm used to looking for the 'return' now, and when I see it, I know that nothing after it will be printed.


** Problem 5
1) Edit the method in exercise #4 so that it does print words on the screen;
2) What does it return now?

*** Andrew's Answer
My guess before I do anything is that if I remove (or simply comment out) the 'return', it will return "Yipeee!!!!" Let's try:


1. *File:* [[file:04_methods/scream.rb][04_methods/scream.rb]]

#+BEGIN_SRC ruby :tangle 04_methods/scream.rb

def scream(words)
  words = words + "!!!!"
#  return
  puts words
end

scream("Yippeee")

#+END_SRC

2. It should print out "Yippeee!!!!"

*** Book Solution

1.
#+BEGIN_SRC ruby

def scream(words)
words = words + "!!!!"
puts words
end
scream("Yippeee")

#+END_SRC

2. still returns *nil*

The key here is that it /prints/ "Yippeee!!!!" but it /returns/ nil. Watching the *Video Walkthrough* made this clear to me. In irb:

#+BEGIN_SRC ruby
小A曰:irb
irb(main):001:0> def scream(words)
irb(main):002:1> words = words + "!!!!"
irb(main):003:1> puts words
irb(main):004:1> end
=> :scream
irb(main):005:0> scream("Yippeee")
Yippeee!!!!  # <= Prints "Yippeee!!!!"
=> nil       # <= Returns nil

# In this case, if we add a 'hi there' string to the end of the method, Ruby will return that string, regardless of what is printed.
irb(main):006:0> def scream(words)
irb(main):007:1> words = words + "!!!!"
irb(main):008:1> puts words
irb(main):009:1> 'hi there'
irb(main):010:1> end
=> :scream
irb(main):011:0> scream("Yippeee")
Yippeee!!!!    # <= Prints "Yippeee!!!!"
=> "hi there"  # <= Returns "hi there"

#+END_SRC

*Comments*

Aha! The light bulb finally went off for me when I watched the video, and the instructor said, "In Ruby methods, the last thing in the method is the 'return' value, regardless what happens in the method (except for the return keyword.) We've already seen that the return keyword is not necessarily needed in Ruby, but it is needed when we need to explicitly designated a return value, (.e.g., in a conditional statement).

*Keypoint:* Every Ruby program returns something, even if it's only a 'nil'.


In the example, he added 'hi there' before the 'end' statement, and Ruby returned that. Now I understand that Ruby can put/print a value, but still return 'nil'! (And that's what I've been seeing in irb all along!)

** 6. What does the following error message tell you?

#+BEGIN_SRC sh
ArgumentError: wrong number of arguments (1 for 2)
from (irb):1:in `calculate_product\
from (irb):4
from /Users/username/.rvm/rubies/ruby-2.0.0-p353/bin/irb:12:in `<main>'

#+END_SRC

*** Solution 6
In a method called 'calculate_product, only one argument was given, but two were required.
*** Book Solution
You are calling a method (calculate_product in this case) that requires two arguments, but you are only providing one.

* Flow Control
** Conditionals

*** Formed with a combination of logical statments and comparison operators.
Logical Statements:
- if
- else
- elsif
- end

Comparison Operators:
- <
- >
- <=
- >=
- !=
- &&
- ||

*File:* [[05_flow_control/conditional.rb]]  
#+BEGIN_SRC ruby :tangle 05_flow_control/conditional.rb
# 05_flow_control/conditional.rb

puts "Put in a number"
a = gets.chomp.to_i
if a == 3
  puts "a is 3"
elsif a == 4
  puts "a is 4"
else
  puts "a is neither 3, nor 4"
end

#+END_SRC
*Output*
#+BEGIN_SRC sh
小A曰:ruby conditional.rb 
Put in a number
3
a is 3
小A曰:ruby conditional.rb 
Put in a number
4
a is 4
小A曰:ruby conditional.rb 
Put in a number
9
a is neither 3, nor 4

#+END_SRC

*** Valid Ruby Conditionals
#+BEGIN_SRC ruby
# Example 1
  if x == 3
    puts "x is 3"
  end
  
#+END_SRC

#+BEGIN_SRC ruby
# Example 2
  if x == 3
    puts "x is 3"
  elsif x == 4
    puts "x is 4"
  end
  
#+END_SRC

#+BEGIN_SRC ruby
# Example 3
  if x == 3
    puts "x is 3"
  else
    puts "x is NOT 3"
  end
  
#+END_SRC

#+BEGIN_SRC ruby
# Example 4: must use "then" keyword when using 1-line syntax

if x == 3 then puts "x is 3" end

# or

puts "x is 3" if x == 3

#+END_SRC

*unless* is a reserved word that serves as the opposite of *if*:

#+BEGIN_SRC ruby
puts "x is NOT 3" unless x ==3

#+END_SRC

*** Comparisons
- *Key Point*: Comparisons always return a *boolean value*.

  | Symbol | Meaning                  | Comments   |
  |--------+--------------------------+------------|
  | <      | less than                |            |
  | >      | greater than             |            |
  | <=     | less than or equal to    |            |
  | >=     | greater than or equal to |            |
  | ==     | equal to                 | (no '===') |
  | !=     | not equal to             |            |
  | &&     | and                      |            |
  |        | or                       |            |


**** Less than/Greater than

#+BEGIN_SRC ruby
irb(main):022:0> 4 < 5
4 < 5
=> true
irb(main):023:0> 4 > 5
4 > 5
=> false
#+END_SRC

**** Less than or equal to/Greater than or equal to
#+BEGIN_SRC ruby
irb(main):024:0> 4 <= 5
4 <= 5
=> true
irb(main):025:0> 5 >= 5
5 >= 5
=> true
irb(main):026:0> 4 >= 5
4 >= 5
=> false
irb(main):027:0> 4 >= 3
4 >= 3
=> true
irb(main):028:0> 4 >= 4
4 >= 4
=> true

#+END_SRC

**** Is equal to
#+BEGIN_SRC ruby
irb(main):029:0> 5 == 5
5 == 5
=> true
irb(main):030:0> 5 == 6
5 == 6
=> false
irb(main):031:0> '5' == 5
'5' == 5
=> false
#+END_SRC
*Note:* '5' is a string, and that is not equal to an integer (5). You must always compare the same type of data, or you'll get a 'false' boolean value.

**** Is not equal to
#+BEGIN_SRC ruby
irb(main):032:0> 4 != 5
4 != 5
=> true
irb(main):033:0> 4 != 4
4 != 4
=> false
irb(main):034:0> 4 != 156
4 != 156
=> true
#+END_SRC

*** Combining Expressions
1. && 'and' (Expressions on both the right and left of the operator must be true)
   #+BEGIN_SRC ruby
(4 == 4) && (5 == 5)
=> true

(4 == 5) && (5 == 5)
=> false

(4 == 5) && (5 == 6)
=> false
   
   #+END_SRC

2. The "or" Operator (An expression on either side of the operator must be true, or the value will be 'false'.)

   #+BEGIN_SRC ruby
(4 == 4) || (5 == 5)
=> true

(4 == 5) || (5 == 5)
=> true

(4 == 5) || (5 == 6)
=> false
   
   #+END_SRC

3. The "not" Operator (Putting this in front of a boolean expression will negate it.)

#+BEGIN_SRC ruby
!(4 == 4)
=> false
#+END_SRC

** Order of Precedence
1. <=, <, >, >= *Comparison*
2. ==, != *Equality*
3. && *Logical AND*
4. || *Logical OR*

How will the following be evaluated?   
   #+BEGIN_SRC ruby

if x && y || z
# do something
end
   
   #+END_SRC
Answer:
1. if *x && y* = true, *#do something* will be executed.
2. if *x && yY = false, the program will evaluate *|| z*. If true, *#do something* will be executed. If not, the *if* statement will be exited.

** Ternary Operator
- common Ruby idiom to make a quick *if/else* statement in one line.
- Uses a combination of *?* and *:*
- Ruby evaluates the expression to the left of the *?*.
  - If true, it executes the code directly after the *?*.
  - If false, it executes the code directly after the *:*. 

#+BEGIN_SRC ruby
true ? "this is true" : "this is not true"
=> true

false ? "this is true" : "this is not true"
=> false
#+END_SRC

** Case Statement
- Similar to 'if' statements
- Use *reserved words*:
  - *case*
  - *when*
  - *else*
  - *end*
- First define a case and then evaluate the value of the case and what operation to complete if the case is true...
- Modified version of *if/elsif/else* statement

*Here's an example:*

*File:* [[file:05_flow_control/case_statement.rb][05_flow_control/case_statement.rb]]
  #+BEGIN_SRC ruby :tangle 05_flow_control/case_statement.rb
    # case_statement.rb
    a = 5

    case a
    when 5
      puts "a is 5"
    when 6
      puts "a is 6"
    else
      puts "a is neither 5, nor 6"
    end
      
  #+END_SRC

  We can also save the result of a case statement into a variable, which will allow us to not have to write *puts* so many times.

  Here is the refactored file:

  *File:* [[http:05_flow_control/case_statement_refactored.rb%20][05_flow_control/case_statement_refactored.rb]]

  #+BEGIN_SRC ruby :tangle 05_flow_control/case_statement_refactored.rb
# 05_flow_control/case_statement_refactored.rb

a = 5

answer = case a
  when 5 
    "a is 5"
  when 6 
    "a is 6"
  else 
    "a is neither 5, nor 6"
  end

puts answer
  
  #+END_SRC

You can write the same program without a case argument:
*File:* [[file:05_flow_control/case_statement-refactored_no_case_argument.rb][05_flow_control/case_statement-refactored_no_case_argument.rb]]
#+BEGIN_SRC ruby :tangle
# 05_flow_control/case_statement-refactored_no_case_argument.rb
  
  a = 5 
  
  answer = case 
    when a == 5 
      "a is 5" 
    when a == 6 
      "a is 6" 
    else 
      "a is neither 5, nor 6" 
    end 

puts answer
  
#+END_SRC

** True and False
After *if* and *elsif*, we must put an expression that evaluates a boolean value:

#+BEGIN_SRC ruby
      
      a = 5
      if a 
        puts "how can this be true?"
        
      else
  
        puts "it is not true"
  
      end

# output: "how can this be true?"
      
#+END_SRC

We could also write this:
#+BEGIN_SRC ruby
if x = 5 # <= careful, this is not asking 'if x == 5...'; it's assigning the value 'x = 5'
  puts "how can this be true?"
else
  puts "it is not true"
end

#output: "How can this be true?"
#+END_SRC

** Exercises

*** Problem 1
Write down whether the following expressions return true or false. Then type the expressions into irb to see the results.

1. (32 * 4) >= 129
2. false != !true
3. true == 4
4. false == (847 == '874')
5. (!true || (!(100 / 5) == 20) || ((328 / 4) == 82)) || false

*** Solution 1
1. False. 128 isn't greater than or equal to 129.
2. False. False does not /not equal/ true. remove one of the exclamation marks.
3. false. true == true. 4 == 4.
4. true. the statement in parentheses is false.
5. true.
   
*** Book Solution
1. false
2. false
3. false
4. true
5. true

I got them all right!

*** Problem 2
Write a method that takes a string as argument. The method should return the capitalized version of the string, only if the string is longer than 10 characters. (Hint: Ruby's String class has a few methods that would be helpful. Check the [[http://ruby-doc.org/core-2.1.0/String.html][Ruby Docs]]!)

*** Solution 2

*File:* [[file:05_flow_control/string.rb][05_flow_control/capitalize.rb]]
#+BEGIN_SRC ruby :tangle 05_flow_control/capitalize.rb
      def capital(string)
        if string.length > 10
          puts string.upcase!
        else
          puts "You expect me to capitalize #{string}? I don't waste my time capitalizing such short words!"
        end
      end

      capital("it's not a tumor!")
      capital("hey")
#+END_SRC

*** Book Solution
#+BEGIN_SRC ruby
  
  # caps_method.rb
  def caps(string)
    if string.length > 10
      string.upcase
    else string
    end
  end

  puts caps("Joe Smith")
  puts caps("Joe Robertson")
  
#+END_SRC

*** Andrew's Comments
My solution was overly complicated. 'else string' is a lot more elegant. Also, not sure if there's a problem with 'puts' in line 3. Though mine would be good if I wanted to create a custom reply..

*** Problem 3
Write a program that takes a number from the user between 0 and 100 and reports back whether the number is between 0 and 50, 50 and 100, or above 100.

*** Andrew's Solution 3

*File:* [[file:05_flow_control/evaluate_num.rb][05_flow_control/evaluate_num.rb]]
#+BEGIN_SRC ruby :tangle 05_flow_control/evaluate_num.rb
# This was my original attempt; I refined my answer with: 05_flow_control/evaluate_num_simplified.rb

puts "Please choose a number."

number = gets.chomp.to_i

if (number >= 0) &&  (number <= 50)
  puts "Your number is between 0 and 50."
elsif (number >= 50) && (number <= 100)
  puts "Your number is between 50 and 100."
else number >100
  puts "Your number is more than 100."
end

#+END_SRC

*** Book Solution

#+BEGIN_SRC ruby
  # evaluate_num.rb
  puts "Please enter a number between 0 and 100."
  number = gets.chomp.to_i
  if number < 0
    puts "You can't enter a negative number!"
  elsif number <= 50
    puts "#{number} is between 0 and 50"
  elsif number <= 100 puts "#{number} is between 51 and 100"
  else
    puts "#{number} is above 100"
  end
#+END_SRC



*Comments*
My solution was too complicated, and I didn't use interpolation. Let's try again:

*File:* [[file:05_flow_control/evaluate_num_simplified.rb][05_flow_control/evaluate_num_updated.rb]]

#+BEGIN_SRC ruby :tangle 05_flow_control/evaluate_num_updated.rb
    # 05_flow_control/evaluate_num_simplified.rb
        puts "Please enter a number between 0 and 100."
        number = gets.chomp.to_i
        if number < 0
          puts "You've entered a negative number. Please try again."
        elsif number <= 50
          puts "#{number} is between 0 and 50."
        elsif number <= 100
          puts "#{number} is between 51 and 100"
        else
          puts "#{number} is above 100"
        end
#+END_SRC

*** Problem 4
What will each block of code below print to the screen? Write your answer on a piece of paper or in a text editor and then run each block of code to see if you were correct.

#+BEGIN_SRC ruby
  # 1.
   '4' == 4 ? puts("TRUE") : puts("FALSE")
    
    # 2.
    x = 2
    if ((x * 3) / 2) == (4 + 4 - x - 3)
      puts "Did you get it right?"
    else
      puts "Did you?"
    end
    
  # 3.
  y = 9
  x = 10
  if (x + 1) <= (y)
    puts "Alright."
  elsif (x + 1) >= (y)
    puts "Alright now!"
  elsif (y + 1) == x
    puts "ALRIGHT NOW!"
  else puts "Alrighty!"
  end
    
#+END_SRC

**** Andrew's Answer
1. "FALSE"
2. "Did you get it right?"
3. "Alright now!"
**** Book Solution
(Same) I got it right!



*** Problem 5
Rewrite your program from exercise 3 using a case statement. Wrap each statement in a method and make sure they both still work.

*Book Solution*

#+BEGIN_SRC ruby :tangle 05_flow_control/evaluate_num_revisited.rb

# evaluate_num_revisited.rb

def evaluate_num(num)
  if num < 0
    puts "You can't enter a negative num!"
  elsif num <= 50
    puts "#{num} is between 0 and 50"
  elsif num <= 100
    puts "#{num} is between 51 and 100"
  else
    puts "#{num} is above 100"
  end
end

def evaluate_case1_num(num)
  case
  when num < 0
    puts "You can't enter a negative num!"
  when num <= 50
    puts "#{num} is between 0 and 50"
  when num <= 100
    puts "#{num} is between 51 and 100"
  else
    puts "#{num} is above 100"
  end
end

def evaluate_case2_num(num)
  case num
  when 0..50
    puts "#{num} is between 0 and 50"
  when 51..100
    puts "#{num} is between 51 and 100"
  else
    if num < 0
      puts "You can't enter a negative num!"
    else
      puts "#{num} is above 100"
    end
  end
end

puts "Please enter a number between 0 and 100."
number = gets.chomp.to_i

evaluate_num(number)
evaluate_case1_num(number)
evaluate_case2_num(number)

#+END_SRC

*Confession:*
I spent a lot of time trying to make this work, and all of my guesses were way off. I watched the video and retyped the solution a couple times, and it makes sense to me, but I think I need to try another one, to make sure. So here is a different take on Problem 5:

#+BEGIN_SRC ruby :tangle 05_flow_control/problem5_extra_practice.rb
# I had trouble figuring out 05_flow_control/evaluate_num.rb on my own, so I created a new version for practice.
# This program asks how your day was. The length of your answer determines the reply!
      def string_length(num)
        if num == 0
            puts "You have to give me something to work with, here."
        elsif num <= 10
          puts "You're not much with words, are you?"
        elsif num <= 20
          puts "You've got a lot to say."
        else
          puts "Sounds like you had quite a day!"
          end
      end
  
      def string_length_case1(num)
        case
          when num == 0
          puts "You have to give me something to work with, here."
          when num <= 10
          puts "You're not much with words, are you?"
          when num <=20
          puts "You've got a lot to say."
        else
          puts "Sounds like you had quite a day!"
        end
      end
  
      def string_length_case2(num)
        case num
          when 1..10
          puts "You're not much with words, are you?"
          when 11..20
          puts "You've got a lot to say."
          else
          if num == 0
            puts "You have to give me something to work with, here."
          else
            puts "Sounds like you had quite a day!"
          end
        end
      end
  
  puts "Tell me about your day."
  number = gets.chomp.to_s.length
  
  string_length(number)
  string_length_case1(number)
  string_length_case2(number)
    
#+END_SRC

*Comment:* That helped. I understand the difference much better. I'm sure I'll be doing lots of extra problems as I go along, just to make sure I'm grasping the material...
*** Problem 6
When you run the following code...

#+BEGIN_SRC ruby 
    def equal_to_four(x)
      if x == 4
        puts "yup"
      else
        puts "nope"
      end
    
  equal_to_four(5)
        
#+END_SRC

You get the following error message..

#+BEGIN_SRC sh
test_code.rb:96: syntax error, unexpected end-of-input, expecting keyword_end

#+END_SRC
Why do you get this error and how can you fix it?

*** Solution 6
Based on the error messages I've seen so far, Ruby error messages usually seem to be farily easy to debug. In this case, it's missing an 'end' keyword. If we look at the code, the conditional is closed with an 'end' but the method is not (the 'def' is missing a closing 'end').

To fix this, just add one more 'end' at the end of the method, just before the last line, where it's called.

It should look like this:




#+BEGIN_SRC ruby :tangle 05_flow_control/equal_to_four.rb
    def equal_to_four(x)
      if x == 4
        puts "yup"
      else
        puts "nope"
      end
    end                # <= add an 'end' here to close the method.
  equal_to_four(5)
        
#+END_SRC
