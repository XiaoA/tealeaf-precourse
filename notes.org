#+TITLE: Andrew's Learn Ruby Notes
#+AUTHOR: Andrew Buckingham
#+STARTUP: indent
#+OPTIONS: num:nil
#+OPTIONS: html-postamble:nil
#+TODO: TODO(t) | | Started(s) | Waiting(w) | Someday/Maybe(m) | Canceled(c) | DONE(d)(@) | Meeting(M) | Note(n)

* Preparation

** Exercise 1
Create a directory named my_folder and then navigate inside that directory. Create two files named one.rb and two.rb in the my_folder directory. Write a ruby program that outputs the line this is file one when you run the one.rb file. Then write another program that outputs this is file two when you run the two.rb file. (Hint: one.rb should have this in it puts "this is file one")
*** Solution

   #+BEGIN_SRC ruby
     # one.rb
     puts "this is file one"
        #+END_SRC

   #+BEGIN_SRC ruby
     # two.rb
   puts "this is file two"
   #+END_SRC


** Exercise 2
When you are finished with the above and both programs are working correctly, navigate to the directory above the my_folder directory and delete all of the content you generated with one command.
*** Solution
#+BEGIN_SRC sh
小A曰:ls
one.rb	two.rb
小A曰:cd ..
小A曰:ls
my_folder
小A曰:rm -R my_folder/
小A曰:ls
小A曰:
#+END_SRC

* The Basics
** Strings
   - Strings can use either double quotes ("") or single quotes (''), and you can escape quotes, when necessary ('This is Andrew\'s string.')
   - String interpolation (concatenation) *only works with double quotes*
     - Syntax: "Here's how to use string interpolation with a #{Ruby Expression}"
       *Example:*       

   #+BEGIN_SRC ruby 
a = 'ten'
"My favorite number is #{a}!"
   #+END_SRC
** Symbols
- You can use symbols to reference things, like strings, that you don't intend to print or edit.
- Often referred to as "immutable" (though this is apparently not 100% correct)

#+BEGIN_SRC ruby
# Examples of symbols
:name
:a_symbol
:"surprisingly, this is also a symbol" 
   #+END_SRC

** Numbers
Integers do not contain decimal points. Floats do.
  
*** Integers
    9, 1, 4, 1000

*** Floats
    9.1, 44.44409, 9.01234

** nil
The *nil* variable allows us to express an /empty value/ (it equals nothing). Ruby also outputs nil when an expected value is not returned.

In this example, puts prints out a statement, but returns nothing (nil):

   #+BEGIN_SRC ruby
# An example from irb

irb(main):006:0> puts "I love Ruby!"
puts "I love Ruby!"
I love Ruby!
=> nil
irb(main):007:0> 
   #+END_SRC

We can also check to see if a value is equal to nil:

#+BEGIN_SRC ruby
nil.nil?
=> true
irb(main):008:0> "nil".nil?
"nil".nil?
=> false
irb(main):009:0> 0.nil?
0.nil?
=> false
irb(main):010:0> "nothing".nil?
"nothing".nil?
=> false

# Note that following is also false:
irb(main):011:0> false == nil
false == nil
=> false

#+END_SRC

As expected, in the first example, *nil* is equal to 'nil', but strings or numbers (including the string, "nil" have a value, and so they cannot equal the empty value of nil.

When nil is used in a condtional expression, rather than as output, the result will be treated as false, because the value is not empty. Note these examples from the text:

#+BEGIN_SRC ruby
# The xpression is not empty, so it is false.
irb :001 > if nil
irb :002 > puts "Hello, World!"
irb :003 > end
=> nil

# The expression runs, and the output is nil.
irb :001 > if 1
irb :002 > puts "Hello, World!"
irb :003 > end
Hello, World!
=> nil
#+END_SRC

** Operations (Mathematical)
   These work as I would expect (similar to JavaScript).
*** Adding, Subtracting, and Multiplying Integers

*Addition (+)*
    #+BEGIN_SRC ruby
2 + 2
=> 4
    #+END_SRC

    #+RESULTS:
    : 4

*Subtraction (-)*
    #+BEGIN_SRC ruby
49 - 47
=> 2
    
    #+END_SRC

    #+RESULTS:
    : 2

*Multiplication (*)*
#+BEGIN_SRC ruby
144 * 144
=> 20736    
    #+END_SRC

    #+RESULTS:
    : 20736

** Division vs. Modulus

*** Division (/)
    #+BEGIN_SRC ruby
144 / 2
=> 2
    #+END_SRC

    #+RESULTS:
    : 72

*** Modulo
    #+BEGIN_SRC ruby
16 / 4
=> 0

16 / 3
=> 5
    
    #+END_SRC

    #+RESULTS:
    : 5

*** Multiplying Floats and Decimals
    #+BEGIN_SRC ruby
15.0 / 4
=> 3.75

48.0 * 7.2
=> 345.6

    
    #+END_SRC

    #+RESULTS:
    : 3.75

*** Equality Comparison

    #+BEGIN_SRC ruby
4 == 4
=> true

4 == '4'
=> false
      
'book' == "book"
=> true

'four' == 4
=> false

'four' == '4'
=> false

    #+END_SRC

    #+RESULTS:
    : false

*** String Concatenation
    #+BEGIN_SRC ruby
"I love" + " Ruby!"
    
    #+END_SRC

    #+RESULTS:
    : I love Ruby!

#+BEGIN_SRC ruby
"1" + "1" 
#+END_SRC

#+RESULTS:
: 11

    *We cannot concatenate a string and a number*

#+BEGIN_SRC ruby
1 + "Love"
#+END_SRC    

#+RESULTS:
-:3:in `+': String can't be coerced into Fixnum (TypeError)
	from -:3:in `main'
	from -:5:in `<main>'

** Basic Data Structures
   
*** Arrays

    #+BEGIN_SRC ruby
[1,2,3,4]
    
    #+END_SRC

    #+RESULTS:
    | 1 | 2 | 3 | 4 |

    Predictably, the index starts with 0:

    #+BEGIN_SRC ruby
irb(main):012:0> [1, 2, 3, 4] [0]
[1, 2, 3, 4] [0]
=> 1
irb(main):013:0* [1, 2, 3, 4] [1]
[1, 2, 3, 4] [1]
=> 2
irb(main):014:0> [1, 2, 3, 4] [2]
[1, 2, 3, 4] [2]
=> 3
irb(main):015:0> [1, 2, 3, 4] [3]
[1, 2, 3, 4] [3]
=> 4
irb(main):016:0> [1, 2, 3, 4] [4]
[1, 2, 3, 4][4]
=> nil 
    #+END_SRC
In the example above, there is no 4th index, so the result is nil.
    
*** Hashes {}
    - Function as dictionary/key-value pairs
    - consists of a *key* and a *value*.
      + The key is usually represented by a *:symbol*.
      + The value follows the *=>*.

        
#+BEGIN_SRC ruby
irb(main):019:0> {:dog => 'barks'}
{:dog => 'barks'}
=> {:dog=>"barks"}
irb(main):020:0> {:dog => 'barks', :cat => 'meows', :pig => 'oinks'}
{:dog => 'barks', :cat => 'meows', :pig => 'oinks'}
=> {:dog=>"barks", :cat=>"meows", :pig=>"oinks"}
#+END_SRC

We can retrieve any value by its key:    
#+BEGIN_SRC ruby
# Can you spot the error?
irb(main):021:0> 
{dog => 'barks', :cat => 'meows', :pig => 'oinks'}[:cat]
NameError: undefined local variable or method `dog' for main:Object
	from (irb):21
	from /usr/bin/irb:12:in `<main>'
#+END_SRC

In the example above, I forgot to add the ':' before 'dog'. Remember that strings require single or double quotes, and symbols require colons. Without either of these, your statements will throw an error.

I've fixed the error. Now we can search for the sound a cat makes:

#+BEGIN_SRC ruby
irb(main):022:0> {:dog => 'barks', :cat => 'meows', :pig => 'oinks'}[:cat]
{:dog => 'barks', :cat => 'meows', :pig => 'oinks'}[:cat]
=> "meows"{:cat => 'meows'}
#+END_SRC      

Many coding errors are just tiny punctuation or spacing errors. Syntax highlighting can help point those out, but experience reading error messages and a sharp eye are essential traits. For example, I remember once, when I was trying to debug a CSS file, it took me forever to figure out why it wasn't working. It turns out I'd used a colon instead of a semi-colon. Lesson learned...

** Expressions and Return
   - When you use the IRB, you'll see the 'hash rocket': *=>*
   - Everything in Ruby is an expression, and it always returns something, even if only /nil/

*** Puts vs. Return
    - puts: Ruby puts something on the screen, but it doesn't return what is printed to the screen. For example, *do* does something, but it also returns a value. Puts does not return the value.

      In these examples, *put* /prints/ a value to the screen, but it /returns/ nil:

      #+BEGIN_SRC ruby
irb(main):023:0> puts 'stuff'
puts 'stuff'
stuff
=> nil
irb(main):024:0> a = puts 'stuff'
a = puts 'stuff'
stuff
=> nil
irb(main):025:0> puts a
puts a
=> nil
#+END_SRC
      
*** Exercises

**** Problem 1
Add two strings together that, when concatenated, return your first and last name as your full name in one string.

For example, if your name is John Doe, think about how you can put "John" and "Doe" together to get "John Doe".

**** Solution 1
Here are three ways. The first is the one I came up with. It can be run in irb:     
#+BEGIN_SRC ruby
irb(main):026:0> "Andrew " + "Buckingham"
"Andrew " + "Buckingham"
=> "Andrew Buckingham"
#+END_SRC
(Note the space after "Andrew ").

The solution came up with two other ways, by assigning variables in the first case, and using string interpolation in the second:

#+BEGIN_SRC ruby :tangle 02_basics/solution1.rb
# #1: My original, (overly?) simple solution
puts "Andrew " + "Buckingham" # Andrew Buckingham

# #2: From the books's solution; assigns variables and then concatenates them:

fname = "Andrew"
lname = "Buckingham"

puts fname + " " + lname

# #3: From the book's solution; using string interpolation:
puts "#{fname} #{lname}"

#+END_SRC

File: [[file:02_basics/solution1.rb][02_basics/solution01.rb]]
#+BEGIN_SRC sh
# See 02_basics/solution01.rb for Ruby file.
小A曰: ruby solution1.rb 
Andrew Buckingham
Andrew Buckingham
Andrew Buckingham

#+END_SRC



**** Problem 2
2. Use the modulo operator, division, or a combination of both to take a 4 digit number and find 1) the thousands number 2) the hundreds 3) the tens and 4) and the ones.
     
**** Solution 2

#+BEGIN_SRC ruby :tangle 02_basics/solution2.rb
puts 6732 / 1000
puts 6732 % 1000 / 100
puts 6732 % 1000 % 100 / 10
puts 6732 % 1000 %100 % 10     
#+END_SRC

Output: [[file:02_basics/solution2.rb][02_basics/solution2.rb]]
#+BEGIN_SRC sh
小A曰:ruby solution2.rb 
6
7
3
2
#+END_SRC

I'll be honest. I didn't quite understand what I was supposed to do, until I saw the solution. I understood the modulo, because it's the same in JavaScript, and once I saw it, the directions made sense. But this was a fun exercise; it's a very simple preview of the kinds of problem-solving tasks that I'll become better at with practice!

**** Problem 3
Write a program that uses a hash to store a list of movie titles with the year they came out. Then use the *puts* command to make your program print out the year of each movie to the screen. The output for your program should look something like this:

#+BEGIN_SRC ruby
1975
2004
2013
2001
1981
#+END_SRC
**** Solution 3
#+BEGIN_SRC ruby :tangle 02_basics/solution3.rb
       movies = {:The_Empire_Strikes_Back =>'1980',
         :The_Dark_Knight => '2008',
         :Avatar => '2009',
         :The_Blind_Side => '2009',
         :Into_the_Fire => '2010'}  

       puts movies[:The_Empire_Strikes_Back]
       puts movies[:The_Dark_Knight]
       puts movies[:Avatar]
       puts movies[:The_Blind_Side]
       puts movies[:Into_the_Fire]
     #+END_SRC

File: [[file:02_basics/solution3.rb][02_basics/solution3.rb]]
#+BEGIN_SRC sh
小A曰:ruby solution3.rb
1980
2008
2009
2009
2010
#+END_SRC

**** Problem 4
Use the dates from the previous example and store them in an array. Then make your program output the same thing as exercise 3.

File: [[file:02_basics/solution4.rb][02_basics/solution4.rb]]

**** Solution 4
#+BEGIN_SRC ruby :tangle 02_basics/solution4.rb
# My solution
years = [1980, 2008, 2009, 2009, 2010]
puts years

# Book solution
dates = [1980, 2008, 2009, 2009, 2010]

puts dates[0]
puts dates[1]
puts dates[2]
puts dates[3]
puts dates[4]
#+END_SRC

***** TODO Find out if there is a difference between our solutions in practical coding situations
*Note:* My solution looks the same as the book's but I can understand the difference in our approach. My reasoning was that if I created a variable (years), I could call that variable, and it would list the dates. The book calls each index, one at a time. Although the output was the same for me, I wonder if there might be a situation where mine would not work well.

**** Problem 5
Write a program that outputs the factorial of the numbers 5, 6, 7, and 8.
**** Solution 5
I need to create a program that outputs something like this:

#+BEGIN_SRC ruby
puts 5 * 4 * 3 * 2 * 1 
puts 6 * 5 * 4 * 3 * 2 * 1
puts 7 * 6 * 5 * 4 * 3 * 2 * 1
puts 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1
#+END_SRC

It seems like that works in irb. But perhaps I could make it a bit more elegant with variables.

#+BEGIN_SRC ruby :tangle 02_basics/solution5.rb
# Write a program that outputs the factorial of the numbers 5, 6, 7, and 8.
# My solution
five = 5 * 4 * 3 * 2 * 1
six = 6 * 5 * 4 * 3 * 2 * 1
seven = 7 * 6 * 5 * 4 * 3 * 2 * 1
eight = 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1

puts five
puts six
puts seven
puts eight

# Book solution
puts 5 * 4 * 3 * 2 * 1 
puts 6 * 5 * 4 * 3 * 2 * 1
puts 7 * 6 * 5 * 4 * 3 * 2 * 1
puts 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1

# This is the same as what I first came up with, but then I decided to assign variables...

#+END_SRC
***** Note 
It looks like my first instinct was correct; the book came up with the same answer. I suppose the one advantage of using variables would be that I could use them again, if needed. 





