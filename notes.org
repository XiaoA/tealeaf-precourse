#+TITLE: Andrew's Learn Ruby Notes
#+AUTHOR: Andrew Buckingham
#+STARTUP: indent
#+OPTIONS: num:nil
#+OPTIONS: html-postamble:nil
#+TODO: TODO(t) | Started(s) | Waiting(w) | Canceled(c) | DONE(d)(@) | Questions(q) | Note(n)

* Preparation

** Exercise 1
Create a directory named my_folder and then navigate inside that directory. Create two files named one.rb and two.rb in the my_folder directory. Write a ruby program that outputs the line this is file one when you run the one.rb file. Then write another program that outputs this is file two when you run the two.rb file. (Hint: one.rb should have this in it puts "this is file one")
*** Solution

   #+BEGIN_SRC ruby
     # one.rb
     puts "this is file one"
        #+END_SRC

   #+BEGIN_SRC ruby
     # two.rb
   puts "this is file two"
   #+END_SRC


** Exercise 2
When you are finished with the above and both programs are working correctly, navigate to the directory above the my_folder directory and delete all of the content you generated with one command.
*** Solution
#+BEGIN_SRC sh
小A曰:ls
one.rb	two.rb
小A曰:cd ..
小A曰:ls
my_folder
小A曰:rm -R my_folder/
小A曰:ls
小A曰:
#+END_SRC

* The Basics
** Strings
   - Strings can use either double quotes ("") or single quotes (''), and you can escape quotes, when necessary ('This is Andrew\'s string.')
   - String interpolation (concatenation) *only works with double quotes*
     - Syntax: "Here's how to use string interpolation with a #{Ruby Expression}"
       *Example:*       

   #+BEGIN_SRC ruby 
a = 'ten'
"My favorite number is #{a}!"
   #+END_SRC
** Symbols
- You can use symbols to reference things, like strings, that you don't intend to print or edit.
- Often referred to as "immutable" (though this is apparently not 100% correct)

#+BEGIN_SRC ruby
# Examples of symbols
:name
:a_symbol
:"surprisingly, this is also a symbol" 
   #+END_SRC

** Numbers
Integers do not contain decimal points. Floats do.
  
*** Integers
    9, 1, 4, 1000

*** Floats
    9.1, 44.44409, 9.01234

** nil
The *nil* variable allows us to express an /empty value/ (it equals nothing). Ruby also outputs nil when an expected value is not returned.

In this example, puts prints out a statement, but returns nothing (nil):

   #+BEGIN_SRC ruby
# An example from irb

irb(main):006:0> puts "I love Ruby!"
puts "I love Ruby!"
I love Ruby!
=> nil
irb(main):007:0> 
   #+END_SRC

We can also check to see if a value is equal to nil:

#+BEGIN_SRC ruby
nil.nil?
=> true
irb(main):008:0> "nil".nil?
"nil".nil?
=> false
irb(main):009:0> 0.nil?
0.nil?
=> false
irb(main):010:0> "nothing".nil?
"nothing".nil?
=> false

# Note that following is also false:
irb(main):011:0> false == nil
false == nil
=> false

#+END_SRC

As expected, in the first example, *nil* is equal to 'nil', but strings or numbers (including the string, "nil" have a value, and so they cannot equal the empty value of nil.

When nil is used in a condtional expression, rather than as output, the result will be treated as false, because the value is not empty. Note these examples from the text:

#+BEGIN_SRC ruby
# The xpression is not empty, so it is false.
irb :001 > if nil
irb :002 > puts "Hello, World!"
irb :003 > end
=> nil

# The expression runs, and the output is nil.
irb :001 > if 1
irb :002 > puts "Hello, World!"
irb :003 > end
Hello, World!
=> nil
#+END_SRC

** Operations (Mathematical)
   These work as I would expect (similar to JavaScript).
*** Adding, Subtracting, and Multiplying Integers

*Addition (+)*
    #+BEGIN_SRC ruby
2 + 2
=> 4
    #+END_SRC

    #+RESULTS:
    : 4

*Subtraction (-)*
    #+BEGIN_SRC ruby
49 - 47
=> 2
    
    #+END_SRC

    #+RESULTS:
    : 2

*Multiplication (*)*
#+BEGIN_SRC ruby
144 * 144
=> 20736    
    #+END_SRC

    #+RESULTS:
    : 20736

** Division vs. Modulus

*** Division (/)
    #+BEGIN_SRC ruby
144 / 2
=> 2
    #+END_SRC

    #+RESULTS:
    : 72

*** Modulo
    #+BEGIN_SRC ruby
16 / 4
=> 0

16 / 3
=> 5
    
    #+END_SRC

    #+RESULTS:
    : 5

*** Multiplying Floats and Decimals
    #+BEGIN_SRC ruby
15.0 / 4
=> 3.75

48.0 * 7.2
=> 345.6

    
    #+END_SRC

    #+RESULTS:
    : 3.75

*** Equality Comparison

    #+BEGIN_SRC ruby
4 == 4
=> true

4 == '4'
=> false
      
'book' == "book"
=> true

'four' == 4
=> false

'four' == '4'
=> false

    #+END_SRC

    #+RESULTS:
    : false

*** String Concatenation
    #+BEGIN_SRC ruby
"I love" + " Ruby!"
    
    #+END_SRC

    #+RESULTS:
    : I love Ruby!

#+BEGIN_SRC ruby
"1" + "1" 
#+END_SRC

#+RESULTS:
: 11

    *We cannot concatenate a string and a number*

#+BEGIN_SRC ruby
1 + "Love"
#+END_SRC    

#+RESULTS:
-:3:in `+': String can't be coerced into Fixnum (TypeError)
	from -:3:in `main'
	from -:5:in `<main>'

** Basic Data Structures
   
*** Arrays

    #+BEGIN_SRC ruby
[1,2,3,4]
    
    #+END_SRC

    #+RESULTS:
    | 1 | 2 | 3 | 4 |

    Predictably, the index starts with 0:

    #+BEGIN_SRC ruby
irb(main):012:0> [1, 2, 3, 4] [0]
[1, 2, 3, 4] [0]
=> 1
irb(main):013:0* [1, 2, 3, 4] [1]
[1, 2, 3, 4] [1]
=> 2
irb(main):014:0> [1, 2, 3, 4] [2]
[1, 2, 3, 4] [2]
=> 3
irb(main):015:0> [1, 2, 3, 4] [3]
[1, 2, 3, 4] [3]
=> 4
irb(main):016:0> [1, 2, 3, 4] [4]
[1, 2, 3, 4][4]
=> nil 
    #+END_SRC
In the example above, there is no 4th index, so the result is nil.
    
*** Hashes {}
    - Function as dictionary/key-value pairs
    - consists of a *key* and a *value*.
      + The key is usually represented by a *:symbol*.
      + The value follows the *=>*.

        
#+BEGIN_SRC ruby
irb(main):019:0> {:dog => 'barks'}
{:dog => 'barks'}
=> {:dog=>"barks"}
irb(main):020:0> {:dog => 'barks', :cat => 'meows', :pig => 'oinks'}
{:dog => 'barks', :cat => 'meows', :pig => 'oinks'}
=> {:dog=>"barks", :cat=>"meows", :pig=>"oinks"}
#+END_SRC

We can retrieve any value by its key:    
#+BEGIN_SRC ruby
# Can you spot the error?
irb(main):021:0> 
{dog => 'barks', :cat => 'meows', :pig => 'oinks'}[:cat]
NameError: undefined local variable or method `dog' for main:Object
	from (irb):21
	from /usr/bin/irb:12:in `<main>'
#+END_SRC

In the example above, I forgot to add the ':' before 'dog'. Remember that strings require single or double quotes, and symbols require colons. Without either of these, your statements will throw an error.

I've fixed the error. Now we can search for the sound a cat makes:

#+BEGIN_SRC ruby
irb(main):022:0> {:dog => 'barks', :cat => 'meows', :pig => 'oinks'}[:cat]
{:dog => 'barks', :cat => 'meows', :pig => 'oinks'}[:cat]
=> "meows"{:cat => 'meows'}
#+END_SRC      

Many coding errors are just tiny punctuation or spacing errors. Syntax highlighting can help point those out, but experience reading error messages and a sharp eye are essential traits. For example, I remember once, when I was trying to debug a CSS file, it took me forever to figure out why it wasn't working. It turns out I'd used a colon instead of a semi-colon. Lesson learned...

** Expressions and Return
   - When you use the IRB, you'll see the 'hash rocket': *=>*
   - Everything in Ruby is an expression, and it always returns something, even if only /nil/

*** Puts vs. Return
    - puts: Ruby puts something on the screen, but it doesn't return what is printed to the screen. For example, *do* does something, but it also returns a value. Puts does not return the value.

      In these examples, *put* /prints/ a value to the screen, but it /returns/ nil:

      #+BEGIN_SRC ruby
irb(main):023:0> puts 'stuff'
puts 'stuff'
stuff
=> nil
irb(main):024:0> a = puts 'stuff'
a = puts 'stuff'
stuff
=> nil
irb(main):025:0> puts a
puts a
=> nil
#+END_SRC
      
*** Exercises

**** Problem 1
Add two strings together that, when concatenated, return your first and last name as your full name in one string.

For example, if your name is John Doe, think about how you can put "John" and "Doe" together to get "John Doe".

**** Solution 1
Here are three ways. The first is the one I came up with. It can be run in irb:     
#+BEGIN_SRC ruby
irb(main):026:0> "Andrew " + "Buckingham"
"Andrew " + "Buckingham"
=> "Andrew Buckingham"
#+END_SRC
(Note the space after "Andrew ").

The solution came up with two other ways, by assigning variables in the first case, and using string interpolation in the second:

#+BEGIN_SRC ruby :tangle 02_basics/solution1.rb
# #1: My original, (overly?) simple solution
puts "Andrew " + "Buckingham" # Andrew Buckingham

# #2: From the books's solution; assigns variables and then concatenates them:

fname = "Andrew"
lname = "Buckingham"

puts fname + " " + lname

# #3: From the book's solution; using string interpolation:
puts "#{fname} #{lname}"

#+END_SRC

File: [[file:02_basics/solution1.rb][02_basics/solution01.rb]]
#+BEGIN_SRC sh
# See 02_basics/solution01.rb for Ruby file.
小A曰: ruby solution1.rb 
Andrew Buckingham
Andrew Buckingham
Andrew Buckingham

#+END_SRC



**** Problem 2
2. Use the modulo operator, division, or a combination of both to take a 4 digit number and find 1) the thousands number 2) the hundreds 3) the tens and 4) and the ones.
     
**** Solution 2

#+BEGIN_SRC ruby :tangle 02_basics/solution2.rb
puts 6732 / 1000
puts 6732 % 1000 / 100
puts 6732 % 1000 % 100 / 10
puts 6732 % 1000 %100 % 10     
#+END_SRC

Output: [[file:02_basics/solution2.rb][02_basics/solution2.rb]]
#+BEGIN_SRC sh
小A曰:ruby solution2.rb 
6
7
3
2
#+END_SRC

I'll be honest. I didn't quite understand what I was supposed to do, until I saw the solution. I understood the modulo, because it's the same in JavaScript, and once I saw it, the directions made sense. But this was a fun exercise; it's a very simple preview of the kinds of problem-solving tasks that I'll become better at with practice!

**** Problem 3
Write a program that uses a hash to store a list of movie titles with the year they came out. Then use the *puts* command to make your program print out the year of each movie to the screen. The output for your program should look something like this:

#+BEGIN_SRC ruby
1975
2004
2013
2001
1981
#+END_SRC
**** Solution 3
#+BEGIN_SRC ruby :tangle 02_basics/solution3.rb
       movies = {:The_Empire_Strikes_Back =>'1980',
         :The_Dark_Knight => '2008',
         :Avatar => '2009',
         :The_Blind_Side => '2009',
         :Into_the_Fire => '2010'}  

       puts movies[:The_Empire_Strikes_Back]
       puts movies[:The_Dark_Knight]
       puts movies[:Avatar]
       puts movies[:The_Blind_Side]
       puts movies[:Into_the_Fire]
     #+END_SRC

File: [[file:02_basics/solution3.rb][02_basics/solution3.rb]]
#+BEGIN_SRC sh
小A曰:ruby solution3.rb
1980
2008
2009
2009
2010
#+END_SRC

**** Problem 4
Use the dates from the previous example and store them in an array. Then make your program output the same thing as exercise 3.

File: [[file:02_basics/solution4.rb][02_basics/solution4.rb]]

**** Solution 4
#+BEGIN_SRC ruby :tangle 02_basics/solution4.rb
# My solution
years = [1980, 2008, 2009, 2009, 2010]
puts years

# Book solution
dates = [1980, 2008, 2009, 2009, 2010]

puts dates[0]
puts dates[1]
puts dates[2]
puts dates[3]
puts dates[4]
#+END_SRC

***** TODO Find out if there is a difference between our solutions in practical coding situations
*Note:* My solution looks the same as the book's but I can understand the difference in our approach. My reasoning was that if I created a variable (years), I could call that variable, and it would list the dates. The book calls each index, one at a time. Although the output was the same for me, I wonder if there might be a situation where mine would not work well.

**** Problem 5
Write a program that outputs the factorial of the numbers 5, 6, 7, and 8.
**** Solution 5
I need to create a program that outputs something like this:

#+BEGIN_SRC ruby
puts 5 * 4 * 3 * 2 * 1 
puts 6 * 5 * 4 * 3 * 2 * 1
puts 7 * 6 * 5 * 4 * 3 * 2 * 1
puts 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1
#+END_SRC

It seems like that works in irb. But perhaps I could make it a bit more elegant with variables.

#+BEGIN_SRC ruby :tangle 02_basics/solution5.rb
# Write a program that outputs the factorial of the numbers 5, 6, 7, and 8.
# My solution
five = 5 * 4 * 3 * 2 * 1
six = 6 * 5 * 4 * 3 * 2 * 1
seven = 7 * 6 * 5 * 4 * 3 * 2 * 1
eight = 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1

puts five
puts six
puts seven
puts eight

# Book solution
puts 5 * 4 * 3 * 2 * 1 
puts 6 * 5 * 4 * 3 * 2 * 1
puts 7 * 6 * 5 * 4 * 3 * 2 * 1
puts 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1

# This is the same as what I first came up with, but then I decided to assign variables...

#+END_SRC
***** Note 
It looks like my first instinct was correct; the book came up with the same answer. I suppose the one advantage of using variables would be that I could use them again, if needed.

**** Problem 6
Write a program that calculates the squares of 3 float numbers of your choosing and outputs the result to the screen.

*File:* [[file:02_basics/solution6.rb][02_basics/solution6.rb]]
**** Solution 6
#+BEGIN_SRC ruby :tangle 02_basics/solution6.rb
# Calculate the squares of 3 float numbers of your choosing and outputs the result to the screen.
puts 40.3 * 40.3
puts 59.5959 * 59.5959
puts 999.99191874 * 999.99191874
#+END_SRC

*Bonus*
This summer, I learned the 'get.chomps' method. I think I could use that to create an interactive program here, that asks the user to provide the floats...

*File:* [[file:02_basics/solution6_bonus.rb][02_basics/solution6_bonus.rb]]
#+BEGIN_SRC ruby :tangle 02_basics/solution6_bonus.rb
# Asks user to provide three floats and then outputs the result to the screen.

puts "Please provide three numbers, with decimal points and at least one digit."
first_number = gets.chomp.to_f
second_number = gets.chomp.to_f
third_number = gets.chomp.to_f

puts "I will now give you the squares and cubes of each of the numbers you have provided."


puts "The square of the first number is #{first_number * first_number}. The cube is  #{first_number * first_number * first_number}."
puts "The square of the second number is #{second_number * second_number}. The cube is #{second_number * second_number * second_number}."
puts "The square of the third number is #{third_number * third_number}. The cube is #{third_number * third_number * third_number}."

#+END_SRC
I had trouble getting that to work, because I was trying to concatenate everything, so it kept throwing errors. The lines looked like this:

#+BEGIN_SRC ruby
puts "The square of the first number is " first_number * first_number "." "The cube is " first_number * first_number * first_number "."
#+END_SRC

Based on my experience with JavaScript, that seemed to make sense to me, but I kept getting errors similar to this:

#+BEGIN_SRC sh
solution6_bonus.rb:9:in `+': no implicit conversion of Float into String (TypeError)
	from solution6_bonus.rb:9:in `<main>'
#+END_SRC

I checked the Ruby documentation, and had decided that the problem was that I wasn't using the correct syntax to put strings and variables on the same line. A simple searched revealed the answer: string interpolation! See this link: http://stackoverflow.com/questions/13526847/ruby-puts-string-and-integer-on-same-line

I just thought of one more way to improve the program. Instead of saying, "The square of the first number is..." I can use string interpolation to show the user the number he/she entered.

*File:* [[file:02_basics/solution6_bonus_improved.rb][02_basics/solution6_bonus_improved.rb]]
#+BEGIN_SRC ruby :tangle 02_basics/solution6_bonus_improved.rb
puts "Please provide three numbers, with decimal points and at least one digit."
first_number = gets.chomp.to_f
second_number = gets.chomp.to_f
third_number = gets.chomp.to_f

puts "I will now give you the squares and cubes of each of the numbers you have provided."


puts "The square of #{first_number} is #{first_number * first_number}. The cube is  #{first_number * first_number * first_number}."
puts "The square of #{second_number} is #{second_number * second_number}. The cube is #{second_number * second_number * second_number}."
puts "The square of #{third_number} is #{third_number * third_number}. The cube is #{third_number * third_number * third_number}."

#+END_SRC

And here's the solution from the book:

#+BEGIN_SRC ruby
puts 4.30 * 4.30
puts 6.13 * 6.13
puts 124.34 * 124.34
#+END_SRC

That was a bit of a detour, but I learned a valuable lesson. And it was really fun to solve that problem!
**** Problem 7
What does the following error message tell you?

#+BEGIN_SRC sh
SyntaxError: (irb):2: syntax error, unexpected ')', expecting '}' from /usr/local/rvm/rubies/ruby-2.0.0-rc2/bin/irb:16:in `<main>' 
#+END_SRC
**** Solution 7

*My solution:* "The coder typed a ')' instead of a '}' (probably when closing a hash)."

*The book's solution:* "There is an opening bracket somewhere in the program without a closing bracket following it. It may have happened when creating a hash."

* Variables
- Use this syntax when assigning variables: <variable_name> = <variable value>
- Be careful to assign a variable names that are unique, and yet easy for others (or you, at a later date) to understand.
- Variables contain information that we can use again, and are a useful way to abstract data. As the author reminds us, "It is helpful to think of variables as containers that hold information. Their sole purpose is to label and store data in memory. This data can then be used throughout your program."

** Assigning Value to Variables
   - Use descriptive/understandable variable names
   - Use '=' for assignment.
   - Use snake_case for variable names.
   - '=' is an assignment operator. '==' is an equality variable. Be careful not to confuse them. /(Unlike JS, Ruby does not appear to have a '===' operator.)/

#+BEGIN_SRC ruby
irb(main):032:0* first_name = "Andrew"
first_name = "Andrew"
=> "Andrew"

#+END_SRC

Now, when we call the variable:

#+BEGIN_SRC ruby
irb(main):033:0> first_name
first_name
=> "Andrew"

#+END_SRC

- "Variables point to values in memory."
- The value *Andrew* is a string. We can reference that in our program by calling the variable, *first_name*
   #+BEGIN_SRC ruby
a = 4
# 4

b = a
# 4

a = 7
# 7

b

# b still equals 4, even though variable a = 7.
   
   #+END_SRC

** Variable Scope
- Defined by where the variable was created/initialized
- Determined by blocks
  
*** *Inner scope can access variables initialized in an outer scope, but not vice versa.*

#+BEGIN_SRC ruby
# scope.rb

a = 5 # variable is initialized in the outer scope
3.times do |n| a = 3 # is a accessible here, in an inner scope?
end puts a 

# a = 3
#+END_SRC    

    Another example:

#+BEGIN_SRC ruby
# scope.rb
a = 5

3.times do |n|
  a = 3
  b = 5 # b is initialized in the inner scope
end

puts a
puts b

# is b accessible here, in the outer scope? 
    
#+END_SRC

It didn't work. I got the following error:

#+BEGIN_SRC sh
scope.rb:10:in `<main>': undefined local variable or method `b' for main:Object (NameError)
    
#+END_SRC

According to the book: This is because the variable b is not available outside of the do/end block in which it is initialized. When we call puts b it is not available within that outer scope.

/(This isn't a surprise. I've seen the same behavior in JS.)/

Another example, with a method:
#+BEGIN_SRC ruby
a = 5

def some_method
a = 3
end

puts a

# a = 5
#+END_SRC

From the text:

"What's the value of a? Still 5, because methods create their own scope that's entirely outside of the execution flow. We'll cover this in more detail when we talk about methods, but for now, make sure you don't mix up do/end with methods when you're working with variable scope issues.

*Note: the key distinguishing factor for deciding whether code delimited by {} or do/end is considered a block (and thereby creating a new scope for variables), is seeing if the {} or do/end immediately follows a method invocation.*

For example:

#+BEGIN_SRC ruby
arr = [1, 2, 3]

for i in arr do
  a = 5 # a is initialized here
end

puts a # is it accessible here? (A: Yes!)
    
#+END_SRC

In this case, *for...do/end* did not create a new inner scope, because these are part of standard Ruby language, and not method calls.

(!) New blocks are created when we use *each*, *times*, or other methods, followed by:
    - {}
    - do/end

    
** Exercises

*** Problem 1
Write a program called name.rb that asks the user to type in their name and then prints out a greeting message with their name included.

*File:* [[file:03_variables/name.rb][03_variables/name.rb]]
*** Solution 1

#+BEGIN_SRC ruby :tangle 03_variables/name.rb
# 03_variables/name.rb
# Asks user for his/her name, and prints it out with a greeting.

puts "What's your name?"
name = gets.chomp

puts 'Hello, ' + name + '!'

#+END_SRC

Here's the book's solution. Almost identical.

#+BEGIN_SRC ruby
# name.rb
puts "What is your name?"
name = gets.chomp
puts "Hello " + name
#+END_SRC


*** Problem 2
Write a program called age.rb that asks a user how old they are and then tells them how old they will be in 10, 20, 30 and 40 years. Below is the output for someone 20 years old.

#+BEGIN_SRC ruby
# output of age.rb for someone 20 yrs old
How old are you?
In 10 years you will be: 30
In 20 years you will be: 40
In 30 years you will be: 50
In 40 years you will be: 60

#+END_SRC

*** Solution 2

*File:* [[file:03_variables/age.rb][03_variables/age.rb]]
#+BEGIN_SRC ruby :tangle 03_variables/age.rb
# age.rb

puts "How old are you?"

age = gets.chomp.to_i

puts "In 10 years you will be: #{age + 10}"
puts "In 20 years you will be: #{age + 20}"
puts "In 30 years you will be: #{age + 30}"
puts "In 40 years you will be: #{age + 40}"

#+END_SRC

Here's the solution from the book. Mine's a bit different, but both work. The main difference is that my solution prints each statement on one line, and the book's prints each solution two lines. 
#+BEGIN_SRC ruby
puts "How old are you?" 
age = gets.chomp.to_i 
"In 10 years you will be:" 
puts age + 10 
puts "In 20 years you will be:" 
puts age + 20 
puts "In 30 years you will be:" 
puts age + 30 
puts "In 40 years you will be:" 
puts age + 40
#+END_SRC
**** Note 
A couple things:
1. I learned about the 'to.i' method this summer. It seems to be the equivalent of JavaScript's 'parseInt'. I'll need to look into this more.
2. Are there any practical differences to the way I solved the problem, vs. the way the book did?

*** Problem 3
Add another section onto name.rb that prints the name of the user 10 times. You must do this without explicitly writing the puts method 10 times in a row.

*** Solution 3

*File:* [[file:03_variables/name2.rb]]

#+BEGIN_SRC ruby :tangle 03_variables/name2.rb
# 03_variables/name2.rb (Version II; prints out the greeting ten times)
puts "What is your name?" 
name = gets.chomp 

10.times do
  puts name
end
#+END_SRC

*** Book Solution (Same)

#+BEGIN_SRC ruby
  # name.rb continued 
  10.times do 
    puts name 
  end
#+END_SRC

*Comments*
Yay! I got this right. :)

*** Problem 4
Modify name.rb again so that it first asks the user for their first name, saves it into a variable, and then does the same for the last name. Then outputs their full name all at once.

*** Solution 4


**** Version 1
*File:* [[file:03_variables/name3_version1.rb][03_variables/name3_version1.rb]]

#+BEGIN_SRC ruby :tangle 03_variables/name3_version1.rb
# 03_variables/name3_version1.rb (Version III; prints out full name

puts "What is your first name?" 
first_name = gets.chomp

puts "What is your last name?" 
last_name = gets.chomp 

puts first_name + " " + last_name

#alternatively: puts #{first_name} #{last_name}

#+END_SRC

**** Version 2
*File:* [[03_variables/name3_version2.rb]]

#+BEGIN_SRC ruby :tangle 03_variables/name3_version2.rb
# name.rb (Version III; prints out full name, with interpolation)

puts "What is your first name?" 
first_name = gets.chomp

puts "What is your last name?" 
last_name = gets.chomp 

puts "#{first_name} #{last_name}"

#+END_SRC


**** Book Solution
#+BEGIN_SRC ruby
# name.rb continued again
puts "What is your first name?"
first_name = gets.chomp
puts "Thank you. What is your last name?"
last_name = gets.chomp
puts "Great. So your full name is " + first_name + " " + last_name

#+END_SRC

**** Comments
I didn't have any problems with this one. My name3_version1.rb file is about the same as the book's verison; name2_version2.rb uses string interpolation to achieve the same result.

*** Problem 5
Look at the following programs...

#+BEGIN_SRC ruby
  x = 0
  3.times do
    x += 1
  end
  puts x
#+END_SRC

and...

#+BEGIN_SRC ruby

  y = 0
  3.times do
    y+= 1
    x = y
  end
  puts x

#+END_SRC
What does x print to the screen in each case? Do they both give errors? Are the errors different? Why?

**** My Solution
*Here are my guesses before I test them...*
I think the first one will print '3', because 'X' is defined as '0', and then it is incremented three times. Because the variable is initialized globally, it will be available in the global scope.

X will cause an error in the second example, because 'x' is initialized within the '3.times do' local scope. (BTW, Y = 1)...

And now for the tests...

- I was right for the first one.

- I was also right for the second one. The exact error message was:

  #+BEGIN_SRC sh
test.rb:6:in `<main>': undefined local variable or method `x' for main:Object (NameError)
  
  #+END_SRC

*Here's the book's solution:*
The first prints 3 to the screen. The second throws an error undefined local variable or method because x is not available as it is created within the scope of the do/end block.

*Comments*
I was right, but I should have been a bit more precise with my answer for the second one. The nature of the error was 'undefined local variable or method.'

*** Problem 6
What does the following error message tell you?

#+BEGIN_SRC ruby
NameError: undefined local variable or method `shoes' for main:Object

from (irb):3

from /usr/local/rvm/rubies/ruby-2.0.0-rc2/bin/irb:16:in `<main>'

#+END_SRC

*** Solution 6
The variable 'shoes' was defined locally, and is therefore unavailable in the global scope.

*Here's the book's solution:*
"The program is trying to reference a variable or method named shoes that has not been defined in the program, or is outside of the scope in which it is being called."
